<HTML><HEAD><TITLE>Dinkum Conversions Library</TITLE></HEAD><BODY>

<H1><A NAME="Dinkum Conversions Library">Dinkum Conversions Library</A></H1><HR>

<P>A C++ program can specialize a number of templates from the
<B>Dinkum Conversions Library</B>,
a portable library for converting wide strings and input/output
streams to and from their corresponding multibyte encoding.</P>

<HR>

<H2><A NAME="Conversions Table of Contents">Conversions Table of Contents</A></H2>

<P><B><CODE><A HREF="wbuffer.html">&quot;Dinkum/codecvt/wbuffer&quot;</A>
&#183; <A HREF="wstring.html">&quot;Dinkum/codecvt/wstring&quot;</A>
</CODE></B></P>

<P><B>
<A HREF="multibyte.html">Multibyte Encodings</A>
</B></P>

<P><B>
<A HREF="#Overview">Overview</A>
&#183; <A HREF="#Code Conversions">Code Conversions</A>
</B></P>

<HR>

<H2><A NAME="Overview">Overview</A></H2>

<P>The Dinkum Conversions Library consists of a rich assortment of
<B>code-conversion facets</B>, all suitable as replacements for template
class <CODE>codecvt</CODE>, defined in the header <CODE>&lt;locale&gt;</CODE>
in the Standard C++ library. When you write:</P>

<PRE>#include &lt;fstream&gt;
#include &lt;locale&gt;
.....
    {   // write Hello as one line to a file
    std::wofstream mystr("myfile.txt"); // open file as wide stream
    mystr &lt;&lt; L"Hello" &lt;&lt; std::endl;
    }</PRE>

<P>the program opens a file named <CODE>myfile.txt</CODE> and writes
six wide characters (each of type <CODE>wchar_t</CODE>) to the file, by
converting each of the wide characters in turn to its corresponding
<B>multibyte sequence</B>. (For more details, see the companion essay on
<A HREF="multibyte.html">Multibyte Encodings</A>.)
Wide characters inserted into the stream are
translated, under the hood, by the code-conversion facet
<CODE>codecvt&lt;wchar_t, char, mbstate_t&gt;</CODE> obtained from the
global locale object when the program constructs <CODE>mystr</CODE>.</P>

<P>Similarly, you can construct a <CODE>wifstream</CODE>
object that reads multibyte sequences from a file and converts them in turn
to a sequence of wide characters that the program extracts from the object.
It uses the same code-conversion facet as above.
Unless you explicitly specify otherwise, that facet implements a default
mapping between wide characters and multibyte encodings, which may not
be the mapping you want. Worse, the C++ Standard provides no portable
way to specify the mapping. It leaves each implementation, or programmer,
to supply any desired mappings.</P>

<P>The Dinkum Conversions Library lets you explicitly specify a number
of different mappings, and it works with all the currently popular
implementations of the Standard C++ library. Chances are, it includes the
mapping you want. Say, for example, that you want to convert between Unicode
wide characters within the program and UTF8-encoded files. The header
<CODE>utf8</CODE> defines template class <CODE>codecvt_utf8</CODE>
to do this job. So you can write:</P>

<PRE>#include &lt;fstream&gt;
#include &lt;locale&gt;
#include "Dinkum/codecvt/utf8"
.....
    {   // write Hello as one line to a file
    std::wofstream mystr("myfile.txt"); // open file as wide stream
    std::locale loc(std::locale::classic(),
        new Dinkum::codecvt::codecvt_utf8&lt;wchar_t&gt;);
    mystr.imbue(loc);  // replace codecvt&lt;wchar_t, char, std::mbstate_t&gt;
    mystr &lt;&lt; L"Hello" &lt;&lt; std::endl;
    }</PRE>

<P>In this particular case, the final file contents will be the
pedestrian byte sequence <CODE>Hello\n</CODE>, because all codes in the
basic C character set have the obvious single-byte equivalents. But in general,
the program will translate any valid Unicode code to the appropriate multibyte
sequence in the file.</P>

<P>Now for an important warning: Not all Standard C++ libraries work
properly with all the code-conversion facets presented here. The Dinkum
C++ Library behaves properly in all cases, but others are less reliable.
So the Conversions Library also includes a stream buffer that offloads
the code conversion process from existing stream buffers, and does it
correctly. The header <A HREF="wbuffer.html"><CODE>wbuffer</CODE></A> defines template
class <CODE>wbuffer_convert</CODE>, which is the conversion stream buffer. So with
<I>any</I> Standard C++ library, you can safely replace the code sequence
above with:</P>

<PRE>#include &lt;fstream&gt;
#include &lt;locale&gt;
#include "Dinkum/codecvt/wbuffer"
#include "Dinkum/codecvt/utf8"
.....
    {   // write Hello as one line to a file
    std::ofstream bytestream("myfile.txt"); // open file as byte stream
    Dinkum::codecvt::wbuffer_convert&lt;
        Dinkum::codecvt::codecvt_utf8&lt;wchar_t&gt; &gt;
            mybuf(bytestream.rdbuf());  // construct wide stream buffer object
    std::wostream mystr(&amp;mybuf); // construct wide ostream object
    mystr &lt;&lt; L"Hello" &lt;&lt; std::endl;
    }</PRE>

<P>Template class <CODE>wbuffer_convert</CODE> looks like a wide stream to
the program. It performs all input and output by calling on an underlying
byte stream, typically an existing one from the Standard C++ library.
Internally, it uses any of the code-conversion facets presented
here to perform the wide-to-multibyte mapping.</P>

<P>Still another approach is to perform code conversion as a mapping between
wide and byte strings. The Standard C++ library uses code-conversion facets
only when performing input and output to a file, but the Conversions
Library provides a string converter as well. The header
<A HREF="wstring.html"><CODE>wstring</CODE></A>
defines template class <CODE>wstring_convert</CODE>,
which is the string converter. So you can rewrite the running example above as:</P>

<PRE>#include &lt;fstream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
#include "Dinkum/codecvt/wstring"
#include "Dinkum/codecvt/utf8"
.....
    {   // write Hello as one line to a file
    std::ofstream bytestream("myfile.txt"); // open file as byte stream
    Dinkum::codecvt::wstring_convert&lt;
        Dinkum::codecvt::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
    std::string mbstring = myconv.to_bytes(L"Hello\n");
    mystr &lt;&lt; mbstring;
    }</PRE>

<P>Template class <CODE>string_convert</CODE> also lets you convert from
multibyte to wide strings, of course.</P>

<H2><A NAME="Code Conversions">Code Conversions</A></H2>

<P>Here is a table of the code-conversion facets defined in this
library:</P>

<PRE><B>Header      Wide        Multibyte
File        Code        Code</B>

<A NAME="8859_1">8859_1</A>      UCS2/4      ISO 8859-1
<A NAME="8859_2">8859_2</A>      UCS2/4      ISO 8859-2
<A NAME="8859_3">8859_3</A>      UCS2/4      ISO 8859-3
<A NAME="8859_4">8859_4</A>      UCS2/4      ISO 8859-4
<A NAME="8859_5">8859_5</A>      UCS2/4      ISO 8859-5
<A NAME="8859_6">8859_6</A>      UCS2/4      ISO 8859-6
<A NAME="8859_7">8859_7</A>      UCS2/4      ISO 8859-7
<A NAME="8859_8">8859_8</A>      UCS2/4      ISO 8859-8
<A NAME="8859_9">8859_9</A>      UCS2/4      ISO 8859-9
<A NAME="8859_10">8859_10</A>     UCS2/4      ISO 8859-10
<A NAME="8859_13">8859_13</A>     UCS2/4      ISO 8859-13
<A NAME="8859_14">8859_14</A>     UCS2/4      ISO 8859-14
<A NAME="8859_15">8859_15</A>     UCS2/4      ISO 8859-15
<A NAME="8859_16">8859_16</A>     UCS2/4      ISO 8859-16
<A NAME="baltic">baltic</A>      UCS2/4      ISO IR-179 Baltic
<A NAME="big5">big5</A>        UCS2/4      BIG5 Chinese double byte
<A NAME="cp037">cp037</A>       UCS2/4      Code page 037 IBM US Canada
<A NAME="cp424">cp424</A>       UCS2/4      Code page 424 IBM EBCDIC Hebrew
<A NAME="cp437">cp437</A>       UCS2/4      Code page 437 DOS Latin US
<A NAME="cp500">cp500</A>       UCS2/4      Code page 500 IBM International
<A NAME="cp737">cp737</A>       UCS2/4      Code page 737 DOS Greek
<A NAME="cp775">cp775</A>       UCS2/4      Code page 775 DOS Baltic Rim
<A NAME="cp850">cp850</A>       UCS2/4      Code page 850 DOS Latin1
<A NAME="cp852">cp852</A>       UCS2/4      Code page 852 DOS Latin2
<A NAME="cp855">cp855</A>       UCS2/4      Code page 855 DOS Cyrillic
<A NAME="cp856">cp856</A>       UCS2/4      Code page 856 Hebrew PC
<A NAME="cp857">cp857</A>       UCS2/4      Code page 857 DOS Turkish
<A NAME="cp860">cp860</A>       UCS2/4      Code page 860 DOS Portugese
<A NAME="cp861">cp861</A>       UCS2/4      Code page 861 DOS Icelandic
<A NAME="cp862">cp862</A>       UCS2/4      Code page 862 DOS Hebrew
<A NAME="cp863">cp863</A>       UCS2/4      Code page 863 DOS Canada French
<A NAME="cp864">cp864</A>       UCS2/4      Code page 864 DOS Arabic
<A NAME="cp865">cp865</A>       UCS2/4      Code page 865 DOS Nordic
<A NAME="cp866">cp866</A>       UCS2/4      Code page 866 DOS Cyrillic Russian
<A NAME="cp869">cp869</A>       UCS2/4      Code page 869 DOS Greek2
<A NAME="cp874">cp874</A>       UCS2/4      Code page 874 DOS Thai
<A NAME="cp875">cp875</A>       UCS2/4      Code page 875 IBM Greek
<A NAME="cp932">cp932</A>       UCS2/4      Code page 932 DOS double byte
<A NAME="cp936">cp936</A>       UCS2/4      Code page 936 DOS double byte
<A NAME="cp949">cp949</A>       UCS2/4      Code page 949 DOS double byte
<A NAME="cp950">cp950</A>       UCS2/4      Code page 950 DOS double byte
<A NAME="cp1006">cp1006</A>      UCS2/4      Code page 1006 IBM Arabic
<A NAME="cp1026">cp1026</A>      UCS2/4      Code page 1026 IBM Latin Turkish
<A NAME="cp1250">cp1250</A>      UCS2/4      Code page 1250 
<A NAME="cp1251">cp1251</A>      UCS2/4      Code page 1251
<A NAME="cp1252">cp1252</A>      UCS2/4      Code page 1252
<A NAME="cp1253">cp1253</A>      UCS2/4      Code page 1253
<A NAME="cp1254">cp1254</A>      UCS2/4      Code page 1254
<A NAME="cp1255">cp1255</A>      UCS2/4      Code page 1255
<A NAME="cp1256">cp1256</A>      UCS2/4      Code page 1256
<A NAME="cp1257">cp1257</A>      UCS2/4      Code page 1257
<A NAME="cp1258">cp1258</A>      UCS2/4      Code page 1258
<A NAME="cyrillic">cyrillic</A>    UCS2/4      Code page 10007 Mac Cyrillic
<A NAME="ebcdic">ebcdic</A>      UCS2/4      EBCDIC
<A NAME="euc">euc</A>         UCS2/4      EUC Japanese
<A NAME="euc_0208">euc_0208</A>    JIS X0208   EUC Japanese
<A NAME="gb12345">gb12345</A>     UCS2/4      GB12345-80 double byte
<A NAME="gb2312">gb2312</A>      UCS2/4      GB2312-80 double byte
<A NAME="greek">greek</A>       UCS2/4      Code page 10006 Mac Greek
<A NAME="iceland">iceland</A>     UCS2/4      Code page 10079 Mac Icelandic
<A NAME="jis">jis</A>         UCS2/4      JIS Japanese
<A NAME="jis0201">jis0201</A>     UCS2/4      JIS X0201 Japanese
<A NAME="jis_0208">jis_0208</A>    JIS X0208   JIS Japanese
<A NAME="ksc5601">ksc5601</A>     UCS2/4      KSC5601 Unified Hangul double byte
<A NAME="latin2">latin2</A>      UCS2/4      Code page 10029 Mac Latin2
<A NAME="one_one">one_one</A>     UCS2/4      UCS2/4 transparent, optional header, binary
<A NAME="roman">roman</A>       UCS2/4      Code page 10000 Mac Roman
<A NAME="sjis">sjis</A>        UCS2/4      Shift JIS Japanese
<A NAME="sjis_0208">sjis_0208</A>   JIS X0208   Shift JIS Japanese
<A NAME="turkish">turkish</A>     UCS2/4      Code page 10081 Mac Turkish
<A NAME="utf8">utf8</A>        UCS2/4      UTF-8, optional header
<A NAME="utf8_utf16">utf8_utf16</A>  UTF-16      UTF-8, optional header
<A NAME="utf16">utf16</A>       UCS2/4      UTF-16, optional header, binary</PRE>

<P>The first column gives the name of the header file, in the include
subdirectory <CODE>Dinkum/codecvt</CODE>. The second column describes the
wide-character encoding assumed by the code-conversion facet:</P>

<UL>
<LI><A HREF="multibyte.html#UCS">UCS2/4</A> means Unicode (ISO 10646) encoded within the program
as either a 16-bit integer (UCS-2) or a 32-bit integer (UCS-4).</LI>

<LI><A HREF="multibyte.html#UTF-16">UTF-16</A> means Unicode encoded within the program as either one
or two 16-bit integers. (Note that this does <I>not</I> meet all the
requirements of a valid wide-character encoding for Standard C or
Standard C++.)</LI>

<LI><A HREF="multibyte.html#JIS X0208">JIS X0208</A> means the Japanese standard for encoding wide characters
within the program as 16-bit integers.</LI>
</UL>

<P>The third column briefly describes the multibyte encoding assumed
by the code-conversion facet. For more information, see the header
itself. Many are derived from tables made available by various standards
bodies. In such cases, the header preserves as comments any descriptive
information that accompanies the tables.</P>

<P>All the code-conversion facets are defined as templates with
the common form:</P>

<PRE>template&lt;Elem,
    unsigned long Maxcode = <I>default value</I>&gt;
    class codecvt_XXX {....};</PRE>

<P><CODE>Elem</CODE> is the wide-character type, typically <CODE>wchar_t</CODE>.
<CODE>Maxcode</CODE> is the largest wide-character code that the
code-conversion facet will read or write without reporting a conversion error.
Each facet specifies a default value which is most appropriate for its
multibyte encoding.</P>

<P>If the multibyte description in the table advertises an
&quot;optional header,&quot; the template class also has an optional
third template parameter to provide additional information about
the multibyte encoding. You specify this information as the union
of three enumeration constants:</P>

<UL>
<LI><CODE>consume_header</CODE> -- to consume an initial header
sequence when reading a multibyte sequence and determine the endianness
of the subsequent multibyte sequence to be read</LI>

<LI><CODE>generate_header</CODE> -- to generate an initial header
sequence when writing a multibyte sequence to advertise the endianness
of the subsequent multibyte sequence to be written</LI>

<LI><CODE>little_endian</CODE> -- to generate a multibyte sequence
in little-endian order, as opposed to the default big-endian order</LI>
</UL>

<P>Finally, if the multibyte description in the table is labeled as
&quot;binary,&quot; then it is not suitable for reading and writing
as a text file. Such a multibyte sequence may contain nul bytes
that do not represent nul characters (which makes it unsuitable
for storing in a nul-terminated byte string as well). It may also
contain other bytes that get altered or discarded when reading or
writing text files. Be sure to open files in binary mode if you
read or write wide streams using these code-conversion facets.</P>

<P>To use one of these code-conversion facets, follow the pattern
in the examples given above. In more detail:</P>

<UL>
<LI>Determine which header file <CODE>XXX</CODE>,
from the table above,
implements the code-conversion rule you want to use and include the header
<CODE>&quot;Dinkum/codecvt/XXX&quot;</CODE>
at the top of the C++ source file.</LI>

<LI>Refer to the code-conversion facet by the name
<CODE>Dinkum::codecvt::codecvt_XXX</CODE>. Almost always you will want
to specialize the template class on the element type <CODE>wchar_t</CODE>,
as in <CODE>Dinkum::codecvt::codecvt_XXX&lt;wchar_t&gt;</CODE>.</LI>

<LI>If you want to disallow conversion of wide-character codes above a
certain maximum value, add a second template parameter to specify this
value, as in <CODE>Dinkum::codecvt::codecvt_XXX&lt;wchar_t, 0x10ffff&gt;</CODE>.
(On an implementation with 32-bit wide characters, this particular value
causes a conversion error if the code-conversion facet generates, or is
asked to generate, a Unicode wide-character code that is currently undefined.)</LI>

<LI>If the multibyte description in the table advertises an
&quot;optional header,&quot; you can add a third template parameter
as described above, as in
<CODE>Dinkum::codecvt::codecvt_XXX&lt;wchar_t, 0x10ffff,
generate_header&gt;</CODE>.</LI>
</UL>

<P>For more examples of how to use these code-conversion facets, study
the test code that exercises each facet.</P>

<HR>
<P>See also the
<B><A HREF="index.html">Table of Contents</A></B>
and the <B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by Dinkumware, Ltd. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
