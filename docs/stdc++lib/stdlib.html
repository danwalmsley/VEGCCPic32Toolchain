<HTML><HEAD><TITLE>&lt;stdlib.h&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;stdlib.h&gt;"><CODE>&lt;stdlib.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#EXIT_FAILURE">EXIT_FAILURE</A>
&#183; <A HREF="#EXIT_SUCCESS">EXIT_SUCCESS</A>
&#183; <A HREF="#MB_CUR_MAX">MB_CUR_MAX</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#RAND_MAX">RAND_MAX</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abort">abort</A>
&#183; <A HREF="#abs">abs</A>
&#183; <A HREF="#atexit">atexit</A>
&#183; <A HREF="#atof">atof</A>
&#183; <A HREF="#atoi">atoi</A>
&#183; <A HREF="#atol">atol</A>
&#183; <A HREF="#atoll">atoll</A>
&#183; <A HREF="#bsearch">bsearch</A>
&#183; <A HREF="#calloc">calloc</A>
&#183; <A HREF="#div">div</A>
&#183; <A HREF="#div_t">div_t</A>
&#183; <A HREF="#_Exit">_Exit</A>
&#183; <A HREF="#exit">exit</A>
&#183; <A HREF="#free">free</A>
&#183; <A HREF="#getenv">getenv</A>
&#183; <A HREF="#labs">labs</A>
&#183; <A HREF="#llabs">llabs</A>
&#183; <A HREF="#ldiv">ldiv</A>
&#183; <A HREF="#ldiv_t">ldiv_t</A>
&#183; <A HREF="#lldiv">ldiv</A>
&#183; <A HREF="#lldiv_t">ldiv_t</A>
&#183; <A HREF="#malloc">malloc</A>
&#183; <A HREF="#mblen">mblen</A>
&#183; <A HREF="#mbstowcs">mbstowcs</A>
&#183; <A HREF="#mbtowc">mbtowc</A>
&#183; <A HREF="#qsort">qsort</A>
&#183; <A HREF="#rand">rand</A>
&#183; <A HREF="#realloc">realloc</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#srand">srand</A>
&#183; <A HREF="#strtod">strtod</A>
&#183; <A HREF="#strtof">strtof</A>
&#183; <A HREF="#strtol">strtol</A>
&#183; <A HREF="#strtold">strtold</A>
&#183; <A HREF="#strtoll">strtoll</A>
&#183; <A HREF="#strtoul">strtoul</A>
&#183; <A HREF="#strtoull">strtoull</A>
&#183; <A HREF="#system">system</A>
&#183; <A HREF="#wchar_t">wchar_t</A>
&#183; <A HREF="#wcstombs">wcstombs</A>
&#183; <A HREF="#wctomb">wctomb</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abort_handler_s">abort_handler_s</A>
&#183; <A HREF="#bsearch_s">bsearch_s</A>
&#183; <A HREF="#constraint_handler_t">constraint_handler_t</A>
&#183; <A HREF="#errno_t">errno_t</A>
&#183; <A HREF="#getenv_s">getenv_s</A>
&#183; <A HREF="#ignore_handler_s">ignore_handler_s</A>
&#183; <A HREF="#mbstowcs_s">mbstowcs_s</A>
&#183; <A HREF="#qsort_s">qsort_s</A>
&#183; <A HREF="#rsize_t">rsize_t</A>
&#183; <A HREF="#set_constraint_handler_s">set_constraint_handler_s</A>
&#183; <A HREF="#wcstombs_s">wcstombs_s</A>
&#183; <A HREF="#wctomb_s">wctomb_s</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;stdlib.h&gt;</CODE></B> to declare an
assortment of useful functions and to define the macros and types
that help you use them.</P>

<PRE>    /* MACROS */
#define <A HREF="#EXIT_FAILURE"><B>EXIT_FAILURE</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#EXIT_SUCCESS"><B>EXIT_SUCCESS</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#MB_CUR_MAX"><B>MB_CUR_MAX</B></A> <I>&lt;rvalue integer expression &gt;= 1&gt;</I>
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#RAND_MAX"><B>RAND_MAX</B></A> <I>&lt;integer constant expression &gt;= 32,767&gt;</I>

    /* TYPES */
typedef struct {
    int quot, rem;
    } <A HREF="#div_t"><B>div_t</B></A>;
typedef struct {
    long quot, rem;
    } <A HREF="#ldiv_t"><B>ldiv_t</B></A>;
typedef struct { <B>[added with C99]</B>
    long long quot, rem;
    } <A HREF="#lldiv_t"><B>lldiv_t</B></A>;

typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;
typedef <I>i-type</I> <A HREF="#wchar_t"><B>wchar_t</B></A>; <B>[keyword in C++]</B>

    /* FUNCTIONS */
int <A HREF="#abs"><B>abs</B></A>(int i);
long <A HREF="#abs"><B>abs</B></A>(long i); <B>[C++ only]</B>
long long <A HREF="#abs"><B>abs</B></A>(long long i); <B>[C++ only, added with C99]</B>
long long <A HREF="#llabs"><B>llabs</B></A>(long long i); <B>[added with C99]</B>
long <A HREF="#labs"><B>labs</B></A>(long i);

div_t <A HREF="#div"><B>div</B></A>(int numer, int denom);
ldiv_t <A HREF="#div"><B>div</B></A>(long numer, long denom); <B>[C++ only]</B>
lldiv_t <A HREF="#div"><B>div</B></A>(long long numer, long long denom); <B>[C++ only, added with C99]</B>
lldiv_t <A HREF="#lldiv"><B>lldiv</B></A>(long long numer, long long denom); <B>[added with C99]</B>
ldiv_t <A HREF="#ldiv"><B>ldiv</B></A>(long numer, long denom);

int <A HREF="#rand"><B>rand</B></A>(void);
void <A HREF="#srand"><B>srand</B></A>(unsigned int seed);

double <A HREF="#atof"><B>atof</B></A>(const char *s);
int <A HREF="#atoi"><B>atoi</B></A>(const char *s);
long <A HREF="#atol"><B>atol</B></A>(const char *s);
long long <A HREF="#atoll"><B>atoll</B></A>(const char *s); <B>[added with C99]</B>

double <A HREF="#strtod"><B>strtod</B></A>(const char *restrict s, char **restrict endptr);
float <A HREF="#strtof"><B>strtof</B></A>(const char *restrict s, char **restrict endptr); <B>[added with C99]</B>
long double <A HREF="#strtold"><B>strtold</B></A>(const char *restrict s,
    char **restrict endptr); <B>[added with C99]</B>

long long <A HREF="#strtoll"><B>strtoll</B></A>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B>
unsigned long long <A HREF="#strtoull"><B>strtoull</B></A>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B>

long <A HREF="#strtol"><B>strtol</B></A>(const char *restrict s, char **restrict endptr, int base);
unsigned long <A HREF="#strtoul"><B>strtoul</B></A>(const char *restrict s, char **restrict endptr,
    int base);

void *<A HREF="#calloc"><B>calloc</B></A>(size_t nelem, size_t size);
void <A HREF="#free"><B>free</B></A>(void *ptr);
void *<A HREF="#malloc"><B>malloc</B></A>(size_t size);
void *<A HREF="#realloc"><B>realloc</B></A>(void *ptr, size_t size);

int <A HREF="#mblen"><B>mblen</B></A>(const char *s, size_t n);
size_t <A HREF="#mbstowcs"><B>mbstowcs</B></A>(wchar_t *restrict wcs, const char *restrict s, size_t n);
int <A HREF="#mbtowc"><B>mbtowc</B></A>(wchar_t *restrict pwc, const char *restrict s, size_t n);
size_t <A HREF="#wcstombs"><B>wcstombs</B></A>(char *restrict s, const wchar_t *restrict wcs, size_t n);
int <A HREF="#wctomb"><B>wctomb</B></A>(char *s, wchar_t wchar);

void <A HREF="#_Exit"><B>_Exit</B></A>(int status); <B>[added with C99]</B>
void <A HREF="#exit"><B>exit</B></A>(int status);
void <A HREF="#abort"><B>abort</B></A>(void);
char *<A HREF="#getenv"><B>getenv</B></A>(const char *name);
int <A HREF="#system"><B>system</B></A>(const char *s);

extern "C++"
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce));

extern "C++"
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));

#if __STDC_WANT_LIB_EXT1__ <B>[added with <A HREF="index_ext1.html#TR24731">TR24731</A>]</B>
typedef void (*<A HREF="#constraint_handler_t"><B>constraint_handler_t</B></A>)(const char *restrict s,
    void *restrict p, errno_t errcode);
typedef int <A HREF="#errno_t"><B>errno_t</B></A>;
typedef size_t <A HREF="#rsize_t"><B>rsize_t</B></A>;

constraint_handler_t <A HREF="#set_constraint_handler_s"><B>set_constraint_handler_s</B></A>(
    constraint_handler_t new_hand);
void <A HREF="#abort_handler_s"><B>abort_handler_s</B></A>(const char *restrict s,
    void *restrict p, errno_t errcode);
void <A HREF="#ignore_handler_s"><B>ignore_handler_s</B></A>(const char *restrict s,
    void *restrict p, errno_t errcode);

errno_t <A HREF="#getenv_s"><B>getenv_s</B></A>(size_t *restrict needed, char *restrict s,
    rsize_t maxsize, const char *restrict name);

errno_t <A HREF="#wctomb_s"><B>wctomb_s</B></A>(int *restrict pstat,
    char *restrict s, rsize_t maxsize, wchar_t wchar);
errno_t <A HREF="#mbstowcs_s"><B>mbstowcs_s</B></A>(size_t *restrict psize,
    wchar_t *restrict wcs, rsize_t maxsize,
    const char *restrict s, rsize_t n);
errno_t <A HREF="#wcstombs_s"><B>wcstombs_s</B></A>(size_t *restrict psize,
    char *restrict s, rsize_t maxsize,
    const wchar_t *restrict wcs, rsize_t n);

extern "C++"
    void *<A HREF="#bsearch_s"><B>bsearch_s</B></A>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce,
            void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<A HREF="#bsearch_s"><B>bsearch_s</B></A>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce,
            void *context);

extern "C++"
    void <A HREF="#qsort_s"><B>qsort_s</B></A>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2,
            void *context), <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <A HREF="#qsort_s"><B>qsort_s</B></A>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2,
            void *context);
#endif /* __STDC_WANT_LIB_EXT1__ */</PRE>

<H2><A NAME="abort"><CODE>abort</CODE></A></H2>

<PRE>void <B>abort</B>(void);</PRE>

<P>The function calls
<CODE><A HREF="signal.html#raise">raise</A>(SIGABRT)</CODE>,
which reports the abort signal,
<A HREF="signal.html#SIGABRT"><CODE>SIGABRT</CODE></A>.
Default handling for the abort signal is to cause abnormal
program termination and report unsuccessful termination to the target
environment. Whether or not the target environment flushes output
streams, closes open files, or removes temporary files on abnormal
termination is implementation defined. If you specify handling that causes
<A HREF="signal.html#raise"><CODE>raise</CODE></A>
to return control to <CODE>abort</CODE>, the function calls
<CODE><A HREF="#exit">exit</A>(EXIT_FAILURE)</CODE>,
to report unsuccessful termination with
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>.</P>

<P><CODE>abort</CODE> never returns to its caller.</P>

<H2><A NAME="abort_handler_s"><CODE>abort_handler_s</CODE></A></H2>

<PRE>void <B>abort_handler_s</B>(const char *s, void *p,
    errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The function
writes <CODE>mesg</CODE> to the standard error stream and calls
<CODE><A HREF="#abort">abort</A></CODE>.
It can serve as a
<A HREF="index_ext1.html#constraint handler">constraint handler</A>.</P>

<H2><A NAME="abs"><CODE>abs</CODE></A></H2>

<PRE>int <B>abs</B>(int i);
long <B>abs</B>(long i); <B>[C++ only]</B>
long long <B>abs</B>(long long i); <B>[C++ only, added with C99]</B></PRE>

<P>The function returns the absolute value of
<CODE>i</CODE>, <CODE>|i|</CODE>. The version that accepts
a <I>long</I> argument behaves the same as
<A HREF="#abs"><CODE>labs</CODE></A></P>

<H2><A NAME="atexit"><CODE>atexit</CODE></A></H2>

<PRE>extern "C++"
    int <B>atexit</B>(void (*func)(void)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    int <B>atexit</B>(void (*func)(void));</PRE>

<P>The function registers the function whose address is <CODE>func</CODE>
to be called by
<A HREF="#exit"><CODE>exit</CODE></A> (or when
<A HREF="lib_over.html#main"><CODE>main</CODE></A> returns)
and returns zero if successful.
The functions are called in reverse order of registry. You can register at
least 32 functions.</P>

<P>Furthermore, in C++, if control leaves a called function because
it fails to handle a thrown exception, <CODE>terminate</CODE>
is called.</P>

<P>The function is thread safe.</P>


<H2><A NAME="atof"><CODE>atof</CODE></A></H2>

<PRE>double <B>atof</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtod">strtod</A>(s, 0)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoi"><CODE>atoi</CODE></A></H2>

<PRE>int <B>atoi</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>int</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE>(int)<A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atol"><CODE>atol</CODE></A></H2>

<PRE>long <B>atol</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoll"><CODE>atoll</CODE></A></H2>

<PRE>long long <B>atoll</B>(const char *s); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long long</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtoll">strtoll</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="bsearch"><CODE>bsearch</CODE></A></H2>

<PRE>extern "C++"
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce));</PRE>

<P>The function searches an array of ordered values and returns
the address of an array element that equals the search key <CODE>key</CODE>
(if one exists); otherwise, it returns a null pointer. The array consists
of <CODE>nelem</CODE> elements, each of <CODE>size</CODE> bytes,
beginning with the element whose address is <CODE>base</CODE>.</P>

<P><CODE>bsearch</CODE> calls the comparison function whose address is
<CODE>cmp</CODE> to compare the search key with elements of the array. The
comparison function must return:</P>

<UL>
<LI>a negative value if the search key <CODE>ck</CODE> is less than the
array element <CODE>ce</CODE>

<LI>zero if the two are equal

<LI>a positive value if the search key is greater than the array
element
</UL>

<P><CODE>bsearch</CODE> assumes that the array elements are in nondescending
order according to the same comparison rules that are used by the
comparison function.</P>

<H2><A NAME="bsearch_s"><CODE>bsearch_s</CODE></A></H2>

<PRE>extern "C++"
    void *<B>bsearch_s</B>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce,
            void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<B>bsearch_s</B>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce,
            void *context); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>nelem</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>size</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>key</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>base</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>cmp</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a null pointer.</P>

<P>Otherwise, the function searches an array of ordered values and returns
the address of an array element that equals the search key <CODE>key</CODE>
(if one exists); otherwise, it returns a null pointer. The array consists
of <CODE>nelem</CODE> elements, each of <CODE>size</CODE> bytes,
beginning with the element whose address is <CODE>base</CODE>.</P>

<P><CODE>bsearch</CODE> calls the comparison function whose address is
<CODE>cmp</CODE> to compare the search key with elements of the array,
passing <CODE>context</CODE> as the third argument.
The comparison function must return:</P>

<UL>
<LI>a negative value if the search key <CODE>ck</CODE> is less than the
array element <CODE>ce</CODE>

<LI>zero if the two are equal

<LI>a positive value if the search key is greater than the array
element
</UL>

<P><CODE>bsearch</CODE> assumes that the array elements are in nondescending
order according to the same comparison rules that are used by the
comparison function.</P>

<H2><A NAME="calloc"><CODE>calloc</CODE></A></H2>

<PRE>void *<B>calloc</B>(size_t nelem, size_t size);</PRE>

<P>The function allocates an array object containing <CODE>nelem</CODE>
elements each of size <CODE>size</CODE>, stores zeros in all bytes of the
array, and returns the address of the first element of the array if
successful; otherwise, it returns a null pointer. You can safely convert
the return value to an object pointer of any type whose size in bytes
is not greater than <CODE>size</CODE>.</P>

<H2><A NAME="constraint_handler_t"><CODE>constraint_handler_t</CODE></A></H2>

<PRE>typedef void (*<B>constraint_handler_t</B>(const char *restrict s,
    void *restrict p, errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The type describes a pointer to a function suitable for use as a
<A HREF="index_ext1.html#constraint handler">constraint handler</A>.</P>

<H2><A NAME="div"><CODE>div</CODE></A></H2>

<PRE>div_t <B>div</B>(int numer, int denom);
ldiv_t <B>div</B>(long numer, long denom); <B>[C++ only]</B>
lldiv_t <B>div</B>(long long numer, long long denom); <B>[C++ only, added with C99]</B></PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="div_t"><CODE>div_t</CODE></A></H2>

<PRE>typedef struct {
    int quot, rem;
    } <B>div_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#div"><CODE>div</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>int.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="errno_t"><CODE>errno_t</CODE></A></H2>

<PRE>typedef int <B>errno_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <I>int,</I> used to represent
a value that can be stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="exit"><CODE>exit</CODE></A></H2>

<PRE>void <B>exit</B>(int status);</PRE>

<P>The function calls all functions registered by
<A HREF="#atexit"><CODE>atexit</CODE></A>,
closes all files, and returns control to the target environment. If
<CODE>status</CODE> is zero or
<A HREF="#EXIT_SUCCESS"><CODE>EXIT_SUCCESS</CODE></A>,
the program reports successful termination. If <CODE>status</CODE> is
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>, the
program reports unsuccessful termination. An implementation can define
additional values for <CODE>status</CODE>.</P>

<P><CODE>exit</CODE> never returns to its caller.</P>

<H2><A NAME="_Exit"><CODE>_Exit</CODE></A></H2>

<PRE>void <B>_Exit</B>(int status); <B>[added with C99]</B></PRE>

<P>The function returns control to the target environment. The value of
<CODE>status</CODE> has the same effect as for a call to
<A HREF="#exit"><CODE>exit</CODE></A>. The function does <I>not</I>
call functions registered by
<A HREF="#atexit"><CODE>atexit</CODE></A>. It may or may not
close files.</P>

<P><CODE>_Exit</CODE> never returns to its caller.</P>

<H2><A NAME="EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A></H2>

<PRE>#define <B>EXIT_FAILURE</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports unsuccessful termination.</P>

<H2><A NAME="EXIT_SUCCESS"><CODE>EXIT_SUCCESS</CODE></A></H2>

<PRE>#define <B>EXIT_SUCCESS</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports successful termination.</P>

<H2><A NAME="free"><CODE>free</CODE></A></H2>

<PRE>void <B>free</B>(void *ptr);</PRE>

<P>If <CODE>ptr</CODE> is not a null pointer, the function deallocates
the object whose address is <CODE>ptr</CODE>; otherwise, it does nothing.
You can deallocate only objects that you first allocate by calling
<A HREF="#calloc"><CODE>calloc</CODE></A>,
<A HREF="#malloc"><CODE>malloc</CODE></A>, or
<A HREF="#realloc"><CODE>realloc</CODE></A>.</P>

<H2><A NAME="getenv"><CODE>getenv</CODE></A></H2>

<PRE>char *<B>getenv</B>(const char *name);</PRE>

<P>The function searches an
<B><A NAME="environment list">environment list</A></B>,
which each implementation defines, for an entry
whose name matches the string <CODE>name</CODE>. If
the function finds a match, it returns a pointer to a static-duration
object that holds the definition associated with the target environment
name. Otherwise, it returns a null pointer. Do not alter the value
stored in the object. If you call <CODE>getenv</CODE> again, the value stored
in the object can change. No target environment names are required
of all environments.</P>

<P>The function is thread safe.</P>

<H2><A NAME="getenv_s"><CODE>getenv_s</CODE></A></H2>

<PRE>
errno_t <B>getenv_s</B>(size_t *restrict needed, char *restrict s,
    rsize_t maxsize, const char *restrict name); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>name</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, and <CODE>needed</CODE> is not a null
pointer, the function stores zero in <CODE>*len</CODE>.
It then returns the error code
it reported to the constraint handler.</P>

<P>Otherwise, the function searches the
<B><A HREF="#environment list">environment list</A></B> for an entry
whose name matches the string <CODE>name</CODE>. If
the function finds a match:</P>

<UL>
<LI>if <CODE>needed</CODE> is not a null pointer, the function stores
in <CODE>*len</CODE> the length of the null-terminated definition
associated with the target environment name</LI>

<LI>if that length is less than <CODE>maxsize</CODE>, the function
copies the definition to <CODE>s</CODE> and returns zero

<LI>if that length is not less than <CODE>maxsize</CODE>, the function
stores a null character in <CODE>s[0]</CODE> and returns a nonzero value</LI>
</UL>

<P>If the function does not find a match:</P>

<UL>
<LI>if <CODE>needed</CODE> is not a null pointer, the function stores
zero in <CODE>*len</CODE></LI>

<LI>the function stores a null character in <CODE>s[0]</CODE>
and returns a nonzero value</LI>
</UL>

<H2><A NAME="ignore_handler_s"><CODE>ignore_handler_s</CODE></A></H2>

<PRE>void <B>ignore_handler_s</B>(const char *s, void *p,
    errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The function simply returns.
It can serve as a
<A HREF="index_ext1.html#constraint handler">constraint handler</A>.</P>

<H2><A NAME="labs"><CODE>labs</CODE></A></H2>

<PRE>long <B>labs</B>(long i);</PRE>

<P>The function returns the absolute value of <CODE>i</CODE>,
<CODE>|i|</CODE>, the same as
<A HREF="#abs"><CODE>abs</CODE></A>.</P>

<H2><A NAME="llabs"><CODE>llabs</CODE></A></H2>

<PRE>long long <B>llabs</B>(long long i); <B>[added with C99]</B></PRE>

<P>The function returns the absolute value of <CODE>i</CODE>,
<CODE>|i|</CODE>, the same as
<A HREF="#abs"><CODE>abs</CODE></A>.</P>

<H2><A NAME="ldiv"><CODE>ldiv</CODE></A></H2>

<PRE>ldiv_t <B>ldiv</B>(long numer, long denom);</PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="lldiv"><CODE>lldiv</CODE></A></H2>

<PRE>lldiv_t <B>lldiv</B>(long long numer, long long denom); <B>[added with C99]</B></PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="ldiv_t"><CODE>ldiv_t</CODE></A></H2>

<PRE>typedef struct {
    long quot, rem;
    } <B>ldiv_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#ldiv"><CODE>ldiv</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>long.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="lldiv_t"><CODE>lldiv_t</CODE></A></H2>

<PRE>typedef struct { <B>[added with C99]</B>
    long long quot, rem;
    } <B>lldiv_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#lldiv"><CODE>lldiv</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>long long.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="malloc"><CODE>malloc</CODE></A></H2>

<PRE>void *<B>malloc</B>(size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, and returns
the address of the object if successful; otherwise, it returns a null
pointer. The values stored in the object are indeterminate. You can
safely convert the return value to an object pointer of any type whose
size is not greater than <CODE>size</CODE>.</P>

<H2><A NAME="MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A></H2>

<PRE>#define <B>MB_CUR_MAX</B> <I>&lt;rvalue integer expression &gt;= 1&gt;</I></PRE>

<P>The macro yields the maximum number of characters that constitute a
<A HREF="charset.html#Multibyte Characters">multibyte character</A>
in the current
<A HREF="locale.html">locale</A>. Its value is &lt;=
<A HREF="limits.html#MB_LEN_MAX"><CODE>MB_LEN_MAX</CODE></A>.</P>

<H2><A NAME="mblen"><CODE>mblen</CODE></A></H2>

<PRE>int <B>mblen</B>(const char *s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer, the function returns the
number of bytes in the multibyte string <CODE>s</CODE> that constitute the
next multibyte character, or it returns -1 if the next <CODE>n</CODE>
(or the remaining) bytes do not constitute a valid multibyte character.
<CODE>mblen</CODE> does not include the terminating null in the count of
bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in an internal
static-duration object to determine how
to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<H2><A NAME="mbstowcs"><CODE>mbstowcs</CODE></A></H2>

<PRE>size_t <B>mbstowcs</B>(wchar_t *restrict wcs, const char *restrict s, size_t n);</PRE>

<P>The function stores a wide character string, in successive elements
of the array whose first element has the address <CODE>wcs</CODE>,
by converting, in turn, each of the multibyte characters
in the multibyte string <CODE>s</CODE>.
The string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each character as if by calling
<A HREF="#mbtowc"><CODE>mbtowc</CODE></A> (except that
the internal conversion state stored for that function is unaffected).
It stores at most <CODE>n</CODE> wide characters, stopping after it stores
a null wide character. It returns the number of wide characters it
stores, not counting the null wide character, if all conversions are
successful; otherwise, it returns -1.</P>

<H2><A NAME="mbstowcs_s"><CODE>mbstowcs_s</CODE></A></H2>

<PRE>errno_t <B>mbstowcs_s</B>(size_t *restrict psize,
    wchar_t *restrict wcs, rsize_t maxsize,
    const char *restrict s, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>wcs</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>wcs</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>wcs</CODE> is not a null pointer and <CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>wcs</CODE> is not a null pointer and the wide-character sequence
generated by the function does not end with a null wide character within
the first <CODE>maxsize</CODE> elements</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>wcs</CODE>
is not a null pointer, the function
stores a null wide character at <CODE>wcs[0]]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function stores a wide character string, in successive elements
of the array whose first element has the address <CODE>wcs</CODE>,
by converting, in turn, each of the multibyte characters
in the multibyte string <CODE>s</CODE>.
The string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each character as if by calling
<A HREF="#mbtowc"><CODE>mbtowc</CODE></A> (except that
the internal conversion state stored for that function is unaffected).
It stores at most <CODE>maxsize</CODE> wide characters, stopping after it stores
a null wide character. If the conversion stores no null wide character,
and stores less than <CODE>maxsize</CODE> wide characters, the function
stores a null wide character at the end of the converted wide characters.</P>

<P>The function stores at <CODE>*psize</CODE> the number of converted
wide characters, not counting any terminating null wide character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="mbtowc"><CODE>mbtowc</CODE></A></H2>

<PRE>int <B>mbtowc</B>(wchar_t *restrict pwc, const char *restrict s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>x</CODE>,
the number of bytes in the multibyte string <CODE>s</CODE> that constitute
the next multibyte character.
(<CODE>x</CODE> cannot be greater than
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)
If <CODE>pwc</CODE> is not a null pointer, the function converts the next
multibyte character to its corresponding wide-character value and
stores that value in <CODE>*pwc</CODE>.
It then returns <CODE>x</CODE>, or it
returns -1 if the next <CODE>n</CODE> or the remaining bytes do not
constitute a valid multibyte character. <CODE>mbtowc</CODE> does not include
the terminating null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in an internal static-duration object to determine
how to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="qsort"><CODE>qsort</CODE></A></H2>

<PRE>extern "C++"
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));</PRE>

<P>The function sorts, in place, an array consisting of <CODE>nelem</CODE>
elements, each of <CODE>size</CODE> bytes, beginning with the element whose
address is <CODE>base</CODE>. It calls the comparison function whose address
is <CODE>cmp</CODE> to compare pairs of elements. The comparison function
must return a negative value if <CODE>e1</CODE> is less than <CODE>e2</CODE>,
zero if the two are equal, or a positive value if <CODE>e1</CODE> is greater
than <CODE>e2</CODE>. Two array elements that are equal can appear in the
sorted array in either order.</P>

<H2><A NAME="qsort_s"><CODE>qsort_s</CODE></A></H2>

<PRE>extern "C++"
    void <B>qsort_s</B>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2,
            void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <B>qsort_s</B>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2,
            void *context); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>nelem</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>size</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>base</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>cmp</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function does nothing.</P>

<P>Otherwise, the function sorts, in place, an array consisting of <CODE>nelem</CODE>
elements, each of <CODE>size</CODE> bytes, beginning with the element whose
address is <CODE>base</CODE>. It calls the comparison function whose address
is <CODE>cmp</CODE> to compare pairs of elements,
passing <CODE>context</CODE> as the third argument. The comparison function
must return a negative value if <CODE>e1</CODE> is less than <CODE>e2</CODE>,
zero if the two are equal, or a positive value if <CODE>e1</CODE> is greater
than <CODE>e2</CODE>. Two array elements that are equal can appear in the
sorted array in either order.</P>


<H2><A NAME="rand"><CODE>rand</CODE></A></H2>

<PRE>int <B>rand</B>(void);</PRE>

<P>The function computes a pseudo-random number <CODE>x</CODE> based
on a seed value stored in an internal static-duration object, alters
the stored seed value, and returns <CODE>x</CODE>.
<CODE>x</CODE> is in the interval [0,
<A HREF="#RAND_MAX"><CODE>RAND_MAX</CODE></A>].</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="RAND_MAX"><CODE>RAND_MAX</CODE></A></H2>

<PRE>#define <B>RAND_MAX</B> <I>&lt;integer constant expression &gt;= 32,767&gt;</I></PRE>

<P>The macro yields the maximum value returned by
<A HREF="#rand"><CODE>rand</CODE></A>.</P>

<H2><A NAME="realloc"><CODE>realloc</CODE></A></H2>

<PRE>void *<B>realloc</B>(void *ptr, size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, possibly
obtaining initial stored values from the object
whose address is <CODE>ptr</CODE>.
It returns the address of the new object if successful; otherwise,
it returns a null pointer. You can safely convert the return value
to an object pointer of any type
whose size is not greater than <CODE>size</CODE>.</P>

<P>If <CODE>ptr</CODE> is not a null pointer, it must be the address
of an existing object that you first allocate by calling
<A HREF="#calloc"><CODE>calloc</CODE></A>,
<A HREF="#malloc"><CODE>malloc</CODE></A>, or
<CODE>realloc</CODE>. If the existing object is not larger
than the newly allocated object, <CODE>realloc</CODE> copies the entire
existing object to the initial part of the allocated object. (The
values stored in the remainder of the object are indeterminate.) Otherwise,
the function copies only the initial part of the existing object that
fits in the allocated object. If <CODE>realloc</CODE> succeeds in allocating
a new object, it deallocates the existing object. Otherwise, the existing
object is left unchanged.</P>

<P>If <CODE>ptr</CODE> is a null pointer, the function does not store
initial values in the newly created object.</P>

<H2><A NAME="rsize_t"><CODE>rsize_t</CODE></A></H2>

<PRE>typedef size_t <B>rsize_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <CODE>size_t</CODE>,
used to represent a function argument to be checked on entry
to a function. It is a
<A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
for an argument of type <CODE>rsize_t</CODE> to be greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>.</P>

<H2><A NAME="set_constraint_handler_s"><CODE>set_constraint_handler_s</CODE></A></H2>

<PRE>constraint_handler_t <B>set_constraint_handler_s</B>(
    constraint_handler_t new_hand); <B>[added with TR24731]</B></PRE>

<P>The function sets the pointer to the current
<A HREF="index_ext1.html#constraint handler">constraint handler</A>
to <CODE>new_hand</CODE> and returns the previous pointer.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="srand"><CODE>srand</CODE></A></H2>

<PRE>void <B>srand</B>(unsigned int seed);</PRE>

<P>The function stores the seed value <CODE>seed</CODE>
in a static-duration object that
<A HREF="#rand"><CODE>rand</CODE></A>
uses to compute a pseudo-random number. From a given seed value,
that function always generates the same sequence of return
values. The program behaves as if the target environment calls
<CODE>srand(1)</CODE> at program startup.</P>

<H2><A NAME="strtod"><CODE>strtod</CODE></A></H2>

<PRE>double <B>strtod</B>(const char *restrict s, char **restrict endptr);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by the longest sequence of one or more characters that match
any part of the full pattern for <CODE>strtod</CODE> shown in the diagram.</P>

<P><IMG SRC="strtod0.gif" align="right"></P>

<P><B>Boldface</B> indicates a feature added with
<A HREF="lib_over.html#C99">C99</A>.</P>

<P>Here, <CODE><I>inf</I></CODE> is the sequence of characters <CODE>inf</CODE>
or <CODE>infinity</CODE> with individual letters in either case,
to represent the special value infinity. Similarly, <CODE><I>nan</I></CODE>
is the sequence of characters <CODE>nan</CODE> or <CODE>nan(<I>qualifier</I>)</CODE>
with individual letters in either case, to represent the
special value not-a-number (NaN). A <CODE><I>qualifier</I></CODE> is any sequence
of zero or more letters, digits, and underscores. Each implementation defines
what effect, if any, a <CODE><I>qualifier</I></CODE> has on the actual encoding
of a NaN.</P>

<P>The pattern for a <CODE>strtod</CODE> hexadecimal string
is shown in the diagram.</P>

<P><IMG SRC="strtodx.gif"></P>

<P>Here, <CODE><I>hex</I></CODE> is a hexadecimal digit, in either case, and
a <CODE><I>point</I></CODE> is the
<A HREF="locale.html#decimal_point">decimal-point</A>
character for the current
<A HREF="locale.html#locale">locale</A>.
(It is the dot (<CODE>.</CODE>) in the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale.)
If the string <CODE>s</CODE> matches this pattern, its equivalent value
is the hexadecimal integer represented by any digits to the left of the
<CODE><I>point</I></CODE>, plus the hexadecimal fraction
represented by any digits to the right of the <CODE><I>point</I></CODE>,
times 2 raised to the signed decimal integer power
that follows an optional <CODE>p</CODE> or <CODE>P</CODE>. A leading
minus sign negates the value.</P>

<P>The pattern for a <CODE>strtod</CODE>
decimal string is shown in the diagram.</P>

<P><IMG SRC="strtod.gif"></P>

<P>Here, a <CODE><I>point</I></CODE> is the
<A HREF="locale.html#decimal_point">decimal-point</A>
character for the current
<A HREF="locale.html#locale">locale</A>.
(It is the dot (<CODE>.</CODE>) in the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale.)
If the string <CODE>s</CODE> matches this pattern, its equivalent value
is the decimal integer represented by any digits to the left of the
<CODE><I>point</I></CODE>, plus the decimal fraction
represented by any digits to the right of the <CODE><I>point</I></CODE>,
times 10 raised to the signed decimal integer power
that follows an optional <CODE>e</CODE> or <CODE>E</CODE>. A leading
minus sign negates the value.</P>

<P>In locales other than the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale,
<CODE>strtod</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtof"><CODE>strtof</CODE></A></H2>

<PRE>float <B>strtof</B>(const char *restrict s, char **restrict endptr); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>float.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>. <CODE>strtof</CODE> converts strings exactly as does
<A HREF="#strtod"><CODE>strtod</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtol"><CODE>strtol</CODE></A></H2>

<PRE>long <B>strtol</B>(const char *restrict s, char **restrict endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by the longest sequence of one or more characters that match
the pattern for <CODE>strtol</CODE> shown in the diagram.</P>

<P><IMG SRC="strtol.gif"></P>

<P>The function accepts the sequences
<CODE>0x</CODE> or <CODE>0X</CODE> only
when <CODE>base</CODE> equals zero or 16.
The letters <CODE>a-z</CODE> or <CODE>A-Z</CODE>
represent digits in the range [10, 36).
If <CODE>base</CODE> is in the range
[2, 36], the function accepts only digits
with values less than <CODE>base</CODE>.
If <CODE>base</CODE> == 0, then a leading <CODE>0x</CODE> or <CODE>0X</CODE>
(after any sign) indicates a hexadecimal (base 16) integer, a leading
<CODE>0</CODE> indicates an octal (base 8) integer, and any other valid
pattern indicates a decimal (base 10) integer.</P>

<P>If the string <CODE>s</CODE> matches this pattern, its equivalent
value is the signed integer of the appropriate base represented by
the digits that match the pattern. (A leading minus sign negates the
value.) In locales other than the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale,
<CODE>strtol</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>long,</I>
<CODE>strtol</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns either
<A HREF="limits.html#LONG_MAX"><CODE>LONG_MAX</CODE></A>,
if <CODE>x</CODE> is positive, or
<A HREF="limits.html#LONG_MIN"><CODE>LONG_MIN</CODE></A>,
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="strtold"><CODE>strtold</CODE></A></H2>

<PRE>long double <B>strtold</B>(const char *restrict s,
    char **restrict endptr); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long double.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>. <CODE>strtold</CODE> converts strings exactly as does
<A HREF="#strtod"><CODE>strtod</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtoll"><CODE>strtoll</CODE></A></H2>

<PRE>long long <B>strtoll</B>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.
<CODE>strtoll</CODE> converts strings exactly as does
<A HREF="#strtol"><CODE>strtol</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>long long,</I>
<CODE>strtoll</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns either
<A HREF="limits.html#LLONG_MAX"><CODE>LLONG_MAX</CODE></A>,
if <CODE>x</CODE> is positive, or
<A HREF="limits.html#LLONG_MIN"><CODE>LLONG_MIN</CODE></A>,
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="strtoul"><CODE>strtoul</CODE></A></H2>

<PRE>unsigned long <B>strtoul</B>(const char *restrict s, char **restrict endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>unsigned long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P><CODE>strtoul</CODE> converts strings exactly as does
<A HREF="#strtol"><CODE>strtol</CODE></A>,
but reports a range error only if the equivalent value is too large
to represent as type <I>unsigned long.</I>
In this case, <CODE>strtoul</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULONG_MAX"><CODE>ULONG_MAX</CODE></A>.</P>

<H2><A NAME="strtoull"><CODE>strtoull</CODE></A></H2>

<PRE>unsigned long long <B>strtoull</B>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>unsigned long long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.
<CODE>strtoull</CODE> converts strings exactly as does
<A HREF="#strtoul"><CODE>strtoul</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>unsigned long long,</I>
<CODE>strtoull</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULLONG_MAX"><CODE>ULLONG_MAX</CODE></A>.</P>

<H2><A NAME="system"><CODE>system</CODE></A></H2>

<PRE>int <B>system</B>(const char *s);</PRE>

<P>If <CODE>s</CODE> is not a null pointer, the function passes the string
<CODE>s</CODE> to be executed by a
<B><A NAME="command processor">command processor</A></B>, supplied by
the target environment, and returns the status reported by the command
processor. If <CODE>s</CODE> is a null pointer, the function returns nonzero
only if the target environment supplies a command processor. Each
implementation defines what strings its command processor accepts.</P>

<H2><A NAME="wchar_t"><CODE>wchar_t</CODE></A></H2>

<PRE>typedef <I>i-type</I> <B>wchar_t</B>; <B>[keyword in C++]</B></PRE>

<P>The type is the integer type <CODE><I>i-type</I></CODE> of a
<A HREF="charset.html#wide-character constant">
wide-character constant</A>, such as <CODE>L'X'</CODE>.
You declare an object of type <CODE>wchar_t</CODE> to hold a
<A HREF="charset.html#Wide-Character Encoding">wide character</A>.</P>

<H2><A NAME="wcstombs"><CODE>wcstombs</CODE></A></H2>

<PRE>size_t <B>wcstombs</B>(char *restrict s, const wchar_t *restrict wcs, size_t n);</PRE>

<P>The function stores a multibyte string, in successive elements
of the array whose first element has the address <CODE>s</CODE>,
by converting in turn each of the wide characters
in the string <CODE>wcs</CODE>. The multibyte string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each wide character as if by calling
<A HREF="#wctomb"><CODE>wctomb</CODE></A> (except that the
<A HREF="charset.html#conversion state">conversion state</A>
stored for that function is unaffected). It stores no
more than <CODE>n</CODE> bytes, stopping after it stores a null character. It
returns the number of bytes it stores, not counting the null character,
if all conversions are successful; otherwise, it returns -1.</P>

<H2><A NAME="wcstombs_s"><CODE>wcstombs_s</CODE></A></H2>

<PRE>errno_t <B>wcstombs_s</B>(size_t *restrict psize,
    char *restrict s, rsize_t maxsize,
    const wchar_t *restrict wcs, rsize_t n) <B>[added with TR24731]</B>;</PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>wcs</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is not a null pointer and <CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s</CODE> is not a null pointer and the multibyte sequence
generated by the function does not end with a null character within
the first <CODE>maxsize</CODE> elements</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>s</CODE>
is not a null pointer, the function
stores a null character at <CODE>s[0]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function stores a multibyte string, in successive elements
of the array whose first element has the address <CODE>s</CODE>,
by converting in turn each of the wide characters
in the string <CODE>wcs</CODE>. The multibyte string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each wide character as if by calling
<A HREF="#wctomb"><CODE>wctomb</CODE></A> (except that the
<A HREF="charset.html#conversion state">conversion state</A>
stored for that function is unaffected). It stores no
more than <CODE>maxsize</CODE> bytes, stopping after it stores a null character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.
If the conversion stores no null character,
and stores less than <CODE>maxsize</CODE> characters, the function
stores a null character at the end of the converted characters.</P>

<P>The function stores at <CODE>*psize</CODE> the number of converted
characters, not counting any terminating null character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="wctomb"><CODE>wctomb</CODE></A></H2>

<PRE>int <B>wctomb</B>(char *s, wchar_t wchar);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>N</CODE>,
the number of bytes needed to represent
the multibyte character corresponding
to the wide character <CODE>wchar</CODE>.
<CODE>N</CODE> cannot exceed
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.
The function converts <CODE>wchar</CODE> to its corresponding multibyte
character, which it stores in successive elements of the array whose
first element has the address <CODE>s</CODE>.
It then returns <CODE>N</CODE>, or it returns -1
if <CODE>wchar</CODE> does not correspond to a valid
multibyte character. <CODE>wctomb</CODE> includes the terminating
null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in a static-duration object to determine how to interpret the
multibyte character string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its static-duration object and returns
nonzero; otherwise, it returns zero.</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="wctomb_s"><CODE>wctomb_s</CODE></A></H2>

<PRE>errno_t <B>wctomb_s</B>(int *restrict pstat,
    char *restrict s, rsize_t maxsize, wchar_t wchar); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>pstat</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is not a null pointer and <CODE>maxsize</CODE> is
less than <CODE>N</CODE>, the number of bytes needed to represent
the multibyte character corresponding to the wide character
<CODE>wchar</CODE> (<CODE>N</CODE> cannot exceed
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)</LI>

<LI><CODE>s</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>
</UL>

<P>If such a violation occurs, and <CODE>s</CODE> is not a null
pointer, the function accesses at most the first <CODE>N</CODE> characters
beginning at <CODE>s</CODE>. The function does not store
anything into <CODE>*pstat</CODE>. It returns the error code
it reported to the constraint handler.</P>

<P>Otherwise, if <CODE>s</CODE> is not a null pointer:</P>

<UL>
<LI>the function converts <CODE>wchar</CODE> to its corresponding multibyte
character, which it stores in successive elements of the array whose
first element has the address <CODE>s</CODE></LI>

<LI>it stores in <CODE>*pstat</CODE> either <CODE>N</CODE>,
if <CODE>wchar</CODE> corresponds to a valid multibyte character,
or -1.</LI>
</UL>

<P><CODE>wctomb_s</CODE> includes the terminating
null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in a static-duration object to determine how to interpret the
multibyte character string.</P>

<P>If <CODE>s</CODE> is a null pointer:</P>

<UL>
<LI>if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its static-duration object, stores a nonzero value in <CODE>*pstat</CODE>
and returns a nonzero value</LI>

<LI>otherwise, the function stores zero in <CODE>*pstat</CODE>
and returns zero.</LI>
</UL>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
