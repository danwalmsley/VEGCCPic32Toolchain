<HTML><HEAD><TITLE>&quot;wbuffer.h&quot;</TITLE></HEAD><BODY>

<H1><A NAME="&quot;wbuffer.h&quot;"><CODE>&quot;Dinkum/codecvt/wbuffer.h&quot;</CODE></A></H1><HR>

<P>Include the header <CODE>&quot;Dinkum/codecvt/wbuffer.h&quot;</CODE> to define template
class <CODE>wbuffer_convert</CODE>, for performing conversions between a
wide stream and a byte stream.</P>

<H2><A NAME="wbuffer_convert"><CODE>wbuffer_convert</CODE></A></H2>

<PRE>namespace Dinkum {
    namespace codecvt {
template&lt;class Codecvt,
    class Elem = wchar_t,
    class Tr = std::char_traits&lt;Elem&gt; &gt;
    class wbuffer_convert
        : public std::basic_streambuf&lt;Elem, Tr&gt;
    {
public:
    typedef typename Tr::state_type <B><A HREF="#wbuffer_convert::state_type">state_type</A></B>;

    <B><A HREF="#wbuffer_convert::wbuffer_convert">wbuffer_convert</A></B>(std::streambuf *bytebuf = 0,
        Codecvt *pcvt = new Codecvt,
        state_type state = state_type());

    std::streambuf *<B><A HREF="#wbuffer_convert::rdbuf">rdbuf</A></B>() const;
    std::streambuf *<B><A HREF="#wbuffer_convert::rdbuf">rdbuf</A></B>(std::streambuf *bytebuf);

    state_type <B><A HREF="#wbuffer_convert::state">state</A></B>() const;

<I>    // exposition only
private:
    std::streambuf *<B>bufptr</B>;
    Codecvt *<B>cvtptr</B>;
    state_type <B>cvtstate</B>;</I>
    };
        }  // namespace codecvt
    }  // namespace Dinkum</PRE>

<P>The template class describes a stream buffer that controls the
transmission of elements of type <CODE>Elem</CODE>, whose character traits
are described by the class <CODE>Tr</CODE>, to and from a byte stream
buffer of type <CODE>std::streambuf</CODE>. Conversion between a sequence
of <CODE>Elem</CODE> values and multibyte sequences is performed by an
object of class <CODE>Codecvt&lt;Elem, char, std::mbstate_t&gt;</CODE>,
which meets the requirements of the standard code-conversion facet
<CODE>std::codecvt&lt;Elem, char, std::mbstate_t&gt;</CODE>.</P>

<P>An object of this template class stores:</P>

<UL>
<LI><B><A NAME="bufptr"><CODE>bufptr</CODE></A></B> --
a pointer to its underlying byte stream buffer</LI>

<LI><B><A NAME="cvtptr"><CODE>cvtptr</CODE></A></B> --
a pointer to the allocated conversion object (which is freed
when the <CODE>wbuffer_convert</CODE> object is destroyed)</LI>

<LI><B><A NAME="cvtstate"><CODE>cvtstate</CODE></A></B> --
a conversion state object</LI>
</UL>

<H3><CODE><A NAME="wbuffer_convert::state">wbuffer_convert::state</A></CODE></H3>

<PRE>state_type <B>state</B>() const;</PRE>

<P>The member function returns <CODE>cvtstate</CODE>.</P>

<H3><CODE><A NAME="wbuffer_convert::rdbuf">wbuffer_convert::rdbuf</A></CODE></H3>

<PRE>std::streambuf *<B>rdbuf</B>() const;
std::streambuf *<B>rdbuf</B>(std::streambuf *bytebuf);</PRE>

<P>The first member function returns <CODE>bufptr</CODE>.
The second member function stores <CODE>bytebuf</CODE> in <CODE>bufptr</CODE>.</P>

<H3><CODE><A NAME="wbuffer_convert::wbuffer_convert">wbuffer_convert::wbuffer_convert</A></CODE></H3>

<PRE><B>wbuffer_convert</B>(std::streambuf *bytebuf = 0,
    Codecvt *pcvt = new Codecvt,
    state_type state = state_type());</PRE>

<P>The constructor constructs a stream buffer object, initializes
<CODE>bufptr</CODE> to <CODE>bytebuf</CODE>, initializes
<CODE>cvtptr</CODE> to <CODE>pcvt</CODE>, and initializes
<CODE>cvtstate</CODE> to <CODE>state</CODE>.</P>

<H3><CODE><A NAME="wbuffer_convert::state_type">wbuffer_convert::state_type</A></CODE></H3>

<PRE>typedef typename Codecvt::state_type <B>state_type</B>;</PRE>

<P>The type is a synonym for <CODE>Codecvt::state_type</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html">Table of Contents</A></B>
and the <B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by Dinkumware, Ltd. All rights reserved.</I></P>
<!--V5.30:126I--></BODY></HTML>
