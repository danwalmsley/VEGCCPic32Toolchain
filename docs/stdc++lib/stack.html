<HTML><HEAD><TITLE>&lt;stack&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;stack&gt;"><CODE>&lt;stack&gt;</CODE></A></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;stack&gt;</CODE></B>
to define the template class <CODE>stack</CODE> and several supporting
templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Container&gt;
    class <B><A HREF="#stack">stack</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);

template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#swap">swap</A></B>(stack&lt;Ty, Container&gt;&amp; left,
        stack&lt;Ty, Container&gt;&amp;); <B>[added with C++0X]</B>
}  // namespace std</PRE>

<H2><A NAME="operator!="><CODE>operator!=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator!=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator=="><CODE>operator==</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator==</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#stack"><CODE>stack</CODE></A>. The function returns
<CODE>left.<A HREF="#stack::c">c</A> == right.c</CODE>.</P>

<H2><A NAME="operator&lt;"><CODE>operator&lt;</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#stack"><CODE>stack</CODE></A>. The function returns
<CODE>left.<A HREF="#stack::c">c</A> &lt; right.c</CODE>.</P>

<H2><A NAME="operator&lt;="><CODE>operator&lt;=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"><CODE>operator&gt;</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;="><CODE>operator&gt;=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="stack"><CODE>stack</CODE></A></H2>

<PRE>template&lt;class Ty,
    class Container = deque&lt;Ty&gt; &gt;
    class stack {
public:
    typedef Container <B><A HREF="#stack::container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#stack::value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#stack::size_type">size_type</A></B>;
    typedef typename Container::reference <B><A HREF="#stack::reference">reference</A></B>;
    typedef typename Container::const_reference <B><A HREF="#stack::const_reference">const_reference</A></B>;

    <B><A HREF="#stack::stack">stack</A></B>();
    explicit <B><A HREF="#stack::stack">stack</A></B>(const container_type&amp; cont);
    <B><A HREF="#stack::stack">stack</A></B>(stack&amp;&amp; right); <B>[added with C++0X]</B>
    explicit <B><A HREF="#stack::stack">stack</A></B>(container_type&amp;&amp; cont); <B>[added with C++0X]</B>

    stack <B><A HREF="#stack::operator=">operator=</A></B>(stack&amp;&amp; right); <B>[added with C++0X]</B>
    void <B><A HREF="#stack::swap">swap</A></B>(stack&amp; right); <B>[added with C++0X]</B>

    bool <B><A HREF="#stack::empty">empty</A></B>() const;
    size_type <B><A HREF="#stack::size">size</A></B>() const;

    reference <B><A HREF="#stack::top">top</A></B>();
    const_reference <B><A HREF="#stack::top">top</A></B>() const;
    void <B><A HREF="#stack::push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#stack::push">push</A></B>(value_type&amp;&amp; val); <B>[added with C++0X]</B>
    template&lt;class... Ty&gt;
        void <B><A HREF="#stack::emplace">emplace</A></B>(Ty&amp;&amp;... val); <B>[added with C++0X]</B>
    void <B><A HREF="#stack::pop">pop</A></B>();

protected:
    Container <B><A HREF="#stack::c">c</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="stack::c"><CODE>c</CODE></A></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#stack::value_type">value_type</A></CODE>.</P>

<P>An object of class <CODE>Container</CODE> must supply
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE>,
<CODE><A HREF="list.html#list">list</A></CODE>, and
<CODE><A HREF="vector.html#vector">vector</A></CODE>
(all of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    typedef T1 <B>reference</B>;
    typedef T2 <B>const_reference</B>;

    <B>Container</B>();
	void <B>swap</B>(Container&amp; right); <B>[added with C++0X]</B>
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    value_type&amp; <B>back</B>();
    const value_type&amp; <B>back</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    template&lt;class... Ty&gt;
        void <B>emplace_back</B>(const Ty&amp;... val); <B>[added with C++0X]</B>
    void <B>pop_back</B>();

    bool operator==(const Container&amp; cont) const;
    bool operator!=(const Container&amp; cont) const;
    bool operator&lt;(const Container&amp; cont) const;
    bool operator&gt;(const Container&amp; cont) const;
    bool operator&lt;=(const Container&amp; cont) const;
    bool operator&gt;=(const Container&amp; cont) const;</PRE>

<P>Here, <CODE>T0</CODE>, <CODE>T1</CODE>, and <CODE>T2</CODE> are unspecified
types that meet the stated requirements.</P>

<H3><CODE><A NAME="stack::const_reference">stack::const_reference</A></CODE></H3>

<PRE>typedef typename Container::const_reference <B>const_reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::const_reference</CODE>.</P>

<H3><CODE><A NAME="stack::container_type">stack::container_type</A></CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="stack::empty">stack::empty</A></CODE></H3>

<H3><CODE><A NAME="stack::emplace">stack::emplace</A></CODE></H3>

<PRE>template&lt;class... Ty&gt;
    void <B>emplace</B>(Ty&amp;&amp;... val); <B>[added with C++0X]</B></PRE>

<P>The member function executes <CODE>c.emplace_back(forward&lt;Ty&gt;(val)...)</CODE>.</P>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="stack::operator=">stack::operator=</A></CODE></H3>

<PRE>stack&gt; <B>operator=</B>(stack&amp;&amp; right); <B>[added with C++0X]</B></PRE>

<P>The operator moves <CODE>right</CODE>, as an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>
to <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="stack::pop">stack::pop</A></CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="stack::push">stack::push</A></CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);
void <B>push</B>(value_type&amp;&amp; val); <B>[added with C++0X]</B></PRE>

<P>The first member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<P>The second member functions is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>.</P>

<H3><CODE><A NAME="stack::reference">stack::reference</A></CODE></H3>

<PRE>typedef typename Container::reference <B>reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::reference</CODE>.</P>

<H3><CODE><A NAME="stack::size">stack::size</A></CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="stack::size_type">stack::size_type</A></CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="stack::stack">stack::stack</A></CODE></H3>

<PRE><B>stack</B>();
explicit <B>stack</B>(const container_type&amp; cont);
<B>stack</B>(stack&amp;&amp; right); <B>[added with C++0X]</B>
explicit <B>stack</B>(container_type&amp;&amp; cont); <B>[added with C++0X]</B></PRE>

<P>The first constructor initializes the stored object with
<CODE><A HREF="#stack::c">c</A>()</CODE>, to specify an
empty initial controlled sequence.
The second constructor initializes the stored object with
<CODE><A HREF="#stack::c">c</A>(cont)</CODE>, to specify an
initial controlled sequence that is a copy of the sequence controlled
by <CODE>cont</CODE>.</P>

<P>The third constructor is a move constructor, and the fourth is the
same as the second but with an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>.</P>

<H3><CODE><A NAME="stack::swap">stack::swap</A></CODE></H3>

<PRE>void <B>swap</B>(stack&amp; right); <B>[added with C++0X]</B></PRE>

<P>The template function swaps <CODE>right</CODE> with <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="stack::top">stack::top</A></CODE></H3>

<PRE>reference <B>top</B>();
const_reference <B>top</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="stack::value_type">stack::value_type</A></CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<H2><CODE><A NAME="swap">swap</A></CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>swap</B>(stack&lt;Ty, Container&gt;&amp; left,
        stack&lt;Ty, Container&gt;&amp;); <B>[added with C++0X]</B></PRE>

<P>The template function executes
<CODE>left.<A HREF="#stack::swap">swap</A>(right)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &#169; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
