<HTML><HEAD><TITLE>&lt;type_traits&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;type_traits&gt;"><CODE>&lt;type_traits&gt;</CODE></A></H1>

<P>[added with
<A HREF="index.html#TR1">TR1</A>]</P><HR>

<P><B><CODE><A HREF="#add_const">add_const</A>
&#183; <A HREF="#add_cv">add_cv</A>
&#183; <A HREF="#add_pointer">add_pointer</A>
&#183; <A HREF="#add_lvalue_reference">add_lvalue_reference</A>
&#183; <A HREF="#add_reference">add_reference</A>
&#183; <A HREF="#add_rvalue_reference">add_rvalue_reference</A>
&#183; <A HREF="#add_volatile">add_volatile</A>
&#183; <A HREF="#aligned_storage">aligned_storage</A>
&#183; <A HREF="#alignment_of">alignment_of</A>
&#183; <A HREF="#common_type">common_type</A>
&#183; <A HREF="#conditional">conditional</A>
&#183; <A HREF="#decay">decay</A>
&#183; <A HREF="#enable_if">enable_if</A>
&#183; <A HREF="#extent">extent</A>
&#183; <A HREF="#has_nothrow_assign">has_nothrow_assign</A>
&#183; <A HREF="#has_nothrow_constructor">has_nothrow_constructor</A>
&#183; <A HREF="#has_nothrow_copy">has_nothrow_copy</A>
&#183; <A HREF="#has_nothrow_copy_constructor">has_nothrow_copy_constructor</A>
&#183; <A HREF="#has_nothrow_default_constructor">has_nothrow_default_constructor</A>
&#183; <A HREF="#has_trivial_assign">has_trivial_assign</A>
&#183; <A HREF="#has_trivial_constructor">has_trivial_constructor</A>
&#183; <A HREF="#has_trivial_copy">has_trivial_copy</A>
&#183; <A HREF="#has_trivial_copy_constructor">has_trivial_copy_constructor</A>
&#183; <A HREF="#has_trivial_default_constructor">has_trivial_default_constructor</A>
&#183; <A HREF="#has_trivial_destructor">has_trivial_destructor</A>
&#183; <A HREF="#has_virtual_destructor">has_virtual_destructor</A>
&#183; <A HREF="#is_abstract">is_abstract</A>
&#183; <A HREF="#is_arithmetic">is_arithmetic</A>
&#183; <A HREF="#is_array">is_array</A>
&#183; <A HREF="#is_base_of">is_base_of</A>
&#183; <A HREF="#is_class">is_class</A>
&#183; <A HREF="#is_compound">is_compound</A>
&#183; <A HREF="#is_const">is_const</A>
&#183; <A HREF="#is_convertible">is_convertible</A>
&#183; <A HREF="#is_empty">is_empty</A>
&#183; <A HREF="#is_enum">is_enum</A>
&#183; <A HREF="#is_floating_point">is_floating_point</A>
&#183; <A HREF="#is_function">is_function</A>
&#183; <A HREF="#is_fundamental">is_fundamental</A>
&#183; <A HREF="#is_integral">is_integral</A>
&#183; <A HREF="#is_lvalue_reference">is_lvalue_reference</A>
&#183; <A HREF="#is_member_function_pointer">is_member_function_pointer</A>
&#183; <A HREF="#is_member_object_pointer">is_member_object_pointer</A>
&#183; <A HREF="#is_member_pointer">is_member_pointer</A>
&#183; <A HREF="#is_object">is_object</A>
&#183; <A HREF="#is_pod">is_pod</A>
&#183; <A HREF="#is_pointer">is_pointer</A>
&#183; <A HREF="#is_polymorphic">is_polymorphic</A>
&#183; <A HREF="#is_reference">is_reference</A>
&#183; <A HREF="#is_rvalue_reference">is_rvalue_reference</A>
&#183; <A HREF="#is_same">is_same</A>
&#183; <A HREF="#is_scalar">is_scalar</A>
&#183; <A HREF="#is_signed">is_signed</A>
&#183; <A HREF="#is_standard_layout">is_standard_layout</A>
&#183; <A HREF="#is_trivial">is_trivial</A>
&#183; <A HREF="#is_union">is_union</A>
&#183; <A HREF="#is_unsigned">is_unsigned</A>
&#183; <A HREF="#is_void">is_void</A>
&#183; <A HREF="#is_volatile">is_volatile</A>
&#183; <A HREF="#make_signed">make_signed</A>
&#183; <A HREF="#make_unsigned">make_unsigned</A>
&#183; <A HREF="#rank">rank</A>
&#183; <A HREF="#remove_all_extents">remove_all_extents</A>
&#183; <A HREF="#remove_const">remove_const</A>
&#183; <A HREF="#remove_cv">remove_cv</A>
&#183; <A HREF="#remove_extent">remove_extent</A>
&#183; <A HREF="#remove_pointer">remove_pointer</A>
&#183; <A HREF="#remove_reference">remove_reference</A>
&#183; <A HREF="#remove_volatile">remove_volatile</A>
</CODE></B></P>

<P><B><CODE><A HREF="#false_type">false_type</A>
&#183; <A HREF="#integral_constant">integral_constant</A>
&#183; <A HREF="#true_type">true_type</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="index.html#TR1">TR1</A>
header <B><CODE>&lt;type_traits&gt;</CODE></B> to define several templates
that provide compile-time constants giving information about the properties
of their type arguments.</P>

<PRE>namespace std {
    namespace tr1 {
    // HELPER CLASSES
 template&lt;class Ty, Ty v&gt;
    struct <B><A HREF="#integral_constant">integral_constant</A></B>;
 typedef integral_constant&lt;bool, false&gt; <B><A HREF="#false_type">false_type</A></B>;
 typedef integral_constant&lt;bool, true&gt; <B><A HREF="#true_type">true_type</A></B>;

    // TYPE CATEGORIES
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_void">is_void</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_integral">is_integral</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_floating_point">is_floating_point</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_array">is_array</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_pointer">is_pointer</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_lvalue_reference">is_lvalue_reference</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_rvalue_reference">is_rvalue_reference</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_reference">is_reference</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_member_object_pointer">is_member_object_pointer</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_member_function_pointer">is_member_function_pointer</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_enum">is_enum</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_union">is_union</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_class">is_class</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_function">is_function</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_arithmetic">is_arithmetic</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_fundamental">is_fundamental</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_object">is_object</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_scalar">is_scalar</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_compound">is_compound</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_member_pointer">is_member_pointer</A></B>;

    // TYPE PROPERTIES
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_const">is_const</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_volatile">is_volatile</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_pod">is_pod</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_empty">is_empty</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_polymorphic">is_polymorphic</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_abstract">is_abstract</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_standard_layout">is_standard_layout</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_trivial">is_trivial</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_constructor">has_trivial_constructor</A></B>; <B>[removed with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_default_constructor">has_trivial_default_constructor</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_copy">has_trivial_copy</A></B>; <B>[removed with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_copy_constructor">has_trivial_copy_constructor</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_assign">has_trivial_assign</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_trivial_destructor">has_trivial_destructor</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_nothrow_constructor">has_nothrow_constructor</A></B>; <B>[removed with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_nothrow_default_constructor">has_nothrow_default_constructor</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_nothrow_copy">has_nothrow_copy</A></B>; <B>[removed with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_nothrow_copy_constructor">has_nothrow_copy_constructor</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_nothrow_assign">has_nothrow_assign</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#has_virtual_destructor">has_virtual_destructor</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_signed">is_signed</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#is_unsigned">is_unsigned</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#alignment_of">alignment_of</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#rank">rank</A></B>;
 template&lt;class Ty, unsigned I = 0&gt;
    struct <B><A HREF="#extent">extent</A></B>;

    // TYPE COMPARISONS
 template&lt;class Ty1, class Ty2&gt;
    struct <B><A HREF="#is_same">is_same</A></B>;
 template&lt;class From, class To&gt;
    struct <B><A HREF="#is_convertible">is_convertible</A></B>;
 template&lt;class Base, class Derived&gt;
    struct <B><A HREF="#is_base_of">is_base_of</A></B>;

    // CONST-VOLATILE MODIFICATIONS
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_const">remove_const</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_volatile">remove_volatile</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_cv">remove_cv</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_const">add_const</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_volatile">add_volatile</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_cv">add_cv</A></B>;

    // REFERENCE MODIFICATIONS
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_reference">remove_reference</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_reference">add_reference</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_lvalue_reference">add_lvalue_reference</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_rvalue_reference">add_rvalue_reference</A></B>;

    // ARRAY MODIFICATIONS
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_extent">remove_extent</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_all_extents">remove_all_extents</A></B>;

    // POINTER MODIFICATIONS
 template&lt;class Ty&gt;
    struct <B><A HREF="#remove_pointer">remove_pointer</A></B>;
 template&lt;class Ty&gt;
    struct <B><A HREF="#add_pointer">add_pointer</A></B>;

    // OTHER MODIFICATIONS
 template&lt;bool, class Ty&gt;
    struct <B><A HREF="#enable_if">enable_if</A></B>; <B>[added with C++0X]</B>
 template&lt;bool, class Ty1, class Ty2&gt;
    struct <B><A HREF="#conditional">conditional</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#decay">decay</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#make_signed">make_signed</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#make_unsigned">make_unsigned</A></B>; <B>[added with C++0X]</B>
 template&lt;class Ty&gt;
    struct <B><A HREF="#aligned_storage">aligned_storage</A></B>;
 template&lt;class... Ty&gt;
    struct <B><A HREF="#common_type">common_type</A></B>; <B>[added with C++0X]</B>
    }  // namespace tr1
using tr1::add_const; using tr1::add_cv; <B>[added with C++0X]</B>
using tr1::add_pointer; using tr1::add_reference;
using tr1::add_lvalue_reference; using tr1::add_rvalue_reference;
using tr1::add_volatile; using tr1::aligned_storage;
using tr1::alignment_of; using tr1::common_type; using tr1::extent;
using tr1::false_type; using tr1::has_nothrow_assign;
using tr1::has_nothrow_constructor; using tr1::has_nothrow_copy;
using tr1::has_nothrow_copy_constructor;
using tr1::has_nothrow_default_constructor;
using tr1::has_trivial_assign; using tr1::has_trivial_constructor;
using tr1::has_trivial_copy; using tr1::has_trivial_copy_constructor;
using tr1::has_trivial_default_constructor; using tr1::has_trivial_destructor;
using tr1::has_virtual_destructor; using tr1::integral_constant;
using tr1::is_abstract; using tr1::is_arithmetic;
using tr1::is_array; using tr1::is_base_of;
using tr1::is_class; using tr1::is_compound;
using tr1::is_const; using tr1::is_convertible;
using tr1::is_empty; using tr1::is_enum;
using tr1::is_floating_point; using tr1::is_function;
using tr1::is_fundamental; using tr1::is_integral;
using tr1::is_reference; using tr1::is_member_function_pointer;
using tr1::is_member_object_pointer; using tr1::is_member_pointer;
using tr1::is_object; using tr1::is_pod; using tr1::is_pointer;
using tr1::is_polymorphic; using tr1::is_reference;
using tr1::is_rvalue_reference; using tr1::is_same; using tr1::is_scalar;
using tr1::is_signed; using tr1::is_standard_layout; using tr1::is_trivial;
using tr1::is_union; using tr1::is_unsigned; using tr1::is_void;
using tr1::is_volatile; using tr1::make_signed;
using tr1::make_unsigned; using tr1::rank;
using tr1::remove_all_extents; using tr1::remove_const;
using tr1::remove_cv; using tr1::remove_extent;
using tr1::remove_pointer; using tr1::remove_reference;
using tr1::remove_volatile; using tr1::true_type;
}  // namespace std</PRE>

<P>A <B><A NAME="type predicate">type predicate</A></B> is a template taking
one or two type arguments. When a type predicate
<B><A NAME="holds true">holds true</A></B> it is publicly derived, directly or
indirectly, from <A HREF="#true_type">true_type</A>. When a type predicate
<B><A NAME="holds false">holds false</A></B> it is publicly derived, directly or
indirectly, from <CODE><A HREF="#false_type">false_type</A></CODE>.</P>

<P>A <B><A NAME="type modifier">type modifier</A></B> is a template taking
one or more template arguments and having the following member:</P>

<UL>
<LI><CODE>typedef <B><I><A NAME="modified-type">modified-type</A></I></B> <B>type</B>;</CODE></LI>
</UL>

<P>A <B><A NAME="type query">type query</A></B> is a template taking one or more
template arguments. A type query is publicly derived, directly or indirectly,
from <CODE>integral_constant&lt;std::size_t, <I>value</I>&gt;</CODE>; it
<B><A NAME="holds the value">holds the value</A></B> passed as the argument
<CODE>value</CODE>.</P>

<H2><CODE><A NAME="add_const">add_const</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_const</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE>
if <CODE>Ty</CODE> is a reference, a function, or a const-qualified type,
otherwise <CODE>const Ty</CODE>.</P>

<H2><CODE><A NAME="add_cv">add_cv</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_cv</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds the <A HREF="#modified-type">modified-type</A>
<CODE><A HREF="#add_volatile">add_volatile</A>&lt;
<A HREF="#add_const">add_const</A>&lt;Ty&gt; &gt;</CODE>.</P>

<H2><CODE><A NAME="add_pointer">add_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds the <A HREF="#modified-type">modified-type</A>
<CODE>Ty1*</CODE> if <CODE>Ty</CODE> is of the form <CODE>Ty1[N]</CODE>
or <CODE>Ty1&amp;</CODE>, otherwise <CODE>Ty*</CODE>.</P>

<H2><CODE><A NAME="add_lvalue_reference">add_lvalue_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_lvalue_reference</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE>
if <CODE>Ty</CODE> is an lvalue reference,
otherwise <CODE>typename remove_reference&lt;Ty&gt;::type&amp;</CODE>.</P>

<H2><CODE><A NAME="add_reference">add_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_reference</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE>
if <CODE>Ty</CODE> is an lvalue reference,
otherwise <CODE>typename remove_reference&lt;Ty&gt;::type&amp;</CODE>.</P>

<H2><CODE><A NAME="add_rvalue_reference">add_rvalue_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_rvalue_reference</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE>
if <CODE>Ty</CODE> is an lvalue reference,
otherwise <CODE>typename remove_reference&lt;Ty&gt;::type&amp;&amp;</CODE>.</P>

<H2><CODE><A NAME="add_volatile">add_volatile</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>add_volatile</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE>
if <CODE>Ty</CODE> is a reference, a function, or a volatile-qualified type,
otherwise <CODE>volatile Ty</CODE>.</P>

<H2><CODE><A NAME="aligned_storage">aligned_storage</A></CODE></H2>

<PRE>template&lt;std::size_t Len, std::size_t Align&gt;
    struct <B>aligned_storage</B> {
        typedef <I>aligned-type</I> type;
        };</PRE>

<P>The nested typedef <CODE>type</CODE> is a synonym for a POD type with
alignment <CODE>Align</CODE> and size <CODE>Len</CODE>. <CODE>Align</CODE>
must be equal to <CODE>alignment_of&lt;Ty1&gt;::value</CODE> for some type
<CODE>Ty1</CODE>.</P>

<H2><CODE><A NAME="alignment_of">alignment_of</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>alignment_of</B>;</PRE>

<P>The <A HREF="#type query">type query</A>
<A HREF="#holds the value">holds the value</A> of the the alignment of the
type <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="common_type">common_type</A></CODE></H2>

<PRE>template&lt;class... Ty&gt;
    struct <B>common_type</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is:</P>

<UL>
<LI><CODE>Ty</CODE>, if the template parameter pack has exactly one argument</LI>

<LI>the type of the expression <CODE>decltype(true ? Tgen() : Ugen())</CODE>,
where <CODE>Tgen()</CODE> is an imaginary function returning a value of type
<CODE>T&amp;&amp;</CODE> and <CODE>Ugen()</CODE> is an imaginary function
returning a value of type <CODE>U&amp;&amp;</CODE>, if the template parameter
pack has exactly two arguments <CODE>T</CODE> and <CODE>U</CODE></LI>

<LI>the type of the expression <CODE>common_type&lt;typename
common_type&lt;T, U&gt;::type, V...&gt;::type</CODE>, if the parameter pack
has more than two arguments; the types <CODE>T</CODE> and <CODE>U</CODE>
are the first two type arguments, respectively, and <CODE>V...</CODE>
is a parameter pack holding the remainder of the arguments
in the parameter pack.</LI>
</UL>

<H2><CODE><A NAME="conditional">conditional</A></CODE></H2>

<PRE>template&lt;bool pred, class Ty&gt;
    struct <B>conditional</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is either:</P>

<UL>
<LI><CODE>Ty</CODE>, if <CODE>pred</CODE> is true</LI>

<LI>not defined, if <CODE>pred</CODE> is false</LI>
</UL>

<H2><CODE><A NAME="decay">decay</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>decay</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is defined
in the following stages:</P>

<UL>
<LI>The type <CODE>U</CODE> is defined as
<CODE><A HREF="#remove_reference">remove_reference</A>&lt;Ty&gt;::type</CODE>.</LI>

<LI>If <CODE><A HREF="#is_array">is_array</A>&lt;U&gt;::value</CODE> is true,
the modified-type <CODE>type</CODE> is
<CODE><A HREF="#remove_extent">remove_extent</A>&lt;U&gt;::type *</CODE>.</LI>

<LI>Otherwise, if
<CODE><A HREF="#is_function">is_function</A>&lt;U&gt;::value</CODE> is true,
the modified-type <CODE>type</CODE> is
<CODE><A HREF="#add_pointer">add_pointer</A>&lt;U&gt;::type</CODE>.</LI>

<LI>Otherwise, the modified-type <CODE>type</CODE> is
<CODE><A HREF="#remove_cv">remove_cv</A>&lt;U&gt;::type</CODE>.</LI>
</UL>

<H2><CODE><A NAME="enable_if">enable_if</A></CODE></H2>

<PRE>template&lt;bool pred, class Ty1, class Ty2&gt;
    struct <B>enable_if</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is either:</P>

<UL>
<LI><CODE>Ty1</CODE>, if <CODE>pred</CODE> is true</LI>

<LI><CODE>Ty2</CODE>, if <CODE>pred</CODE> is false</LI>
</UL>

<H2><CODE><A NAME="extent">extent</A></CODE></H2>

<PRE>template&lt;class Ty, unsigned I = 0&gt;
    struct <B>extent</B>;</PRE>

<P>The <A HREF="#type query">type query</A>
<A HREF="#holds the value">holds the value</A> of the number of elements in
the <CODE>I<SUP>th</SUP></CODE> bound of objects of type <CODE>Ty</CODE>.
If <CODE>Ty</CODE> is not an array type or its rank is less than <CODE>I</CODE>,
or if <CODE>I</CODE> is zero and <CODE>Ty</CODE> is of type &quot;array of unknown
bound of <CODE>U</CODE>&quot;, it holds the value 0.
</P>

<H2><CODE><A NAME="false_type">false_type</A></CODE></H2>

<PRE>typedef integral_constant&lt;bool, false&gt; <B>false_type</B>;</PRE>

<P>The type is a synonym for a specialization of the template
<CODE>integral_constant</CODE>.</P>

<H2><CODE><A NAME="has_nothrow_assign">has_nothrow_assign</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_nothrow_assign</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> has
a <A HREF="#nothrow">nothrow</A> copy assignment operator,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B><A NAME="nothrow">nothrow</A></B> function is a function that has
an empty throw specifier, or a function which the compiler can otherwise
determine will not throw an exception.</P>

<H2><CODE><A NAME="has_nothrow_constructor">has_nothrow_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_nothrow_constructor</B>; <B>[removed with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> has
a <A HREF="#nothrow">nothrow</A> default constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="has_nothrow_copy">has_nothrow_copy</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_nothrow_copy</B>; <B>[removed with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> has
a <A HREF="#nothrow">nothrow</A> copy constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="has_nothrow_copy_constructor">has_nothrow_copy_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_nothrow_copy_constructor</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> has
only <A HREF="#nothrow">nothrow</A> copy constructors,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="has_nothrow_default_constructor">has_nothrow_default_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_nothrow_default_constructor</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> has
a <A HREF="#nothrow">nothrow</A> default constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="has_trivial_assign">has_trivial_assign</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_assign</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a trivial copy assignment operator,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>copy assignment operator</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is implicitly declared</LI>
<LI>the class <CODE>Ty</CODE> has no virtual functions</LI>
<LI>the class <CODE>Ty</CODE> has no virtual bases</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial copy assignment operators</LI>
<LI>the classes of all the non-static data members of class type have trivial copy assignment operators</LI>
<LI>the classes of all the non-static data members of type array of class have trivial copy assignment operators</LI>
</UL>

<H2><CODE><A NAME="has_trivial_constructor">has_trivial_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_constructor</B>; <B>[removed with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a trivial constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>constructor</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is an implicitly declared default constructor</LI>
<LI>the class <CODE>Ty</CODE> has no virtual functions</LI>
<LI>the class <CODE>Ty</CODE> has no virtual bases</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial constructors</LI>
<LI>the classes of all the non-static data members of class type have trivial constructors</LI>
<LI>the classes of all the non-static data members of type array of class have trivial constructors</LI>
</UL>

<H2><CODE><A NAME="has_trivial_copy">has_trivial_copy</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_copy</B>; <B>[removed with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a trivial copy constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>copy constructor</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is implicitly declared</LI>
<LI>the class <CODE>Ty</CODE> has no virtual functions</LI>
<LI>the class <CODE>Ty</CODE> has no virtual bases</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial copy constructors</LI>
<LI>the classes of all the non-static data members of class type have trivial copy constructors</LI>
<LI>the classes of all the non-static data members of type array of class have trivial copy constructors</LI>
</UL>

<H2><CODE><A NAME="has_trivial_copy_constructor">has_trivial_copy_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_copy_constructor</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has only trivial copy constructors,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>copy constructor</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is implicitly declared</LI>
<LI>the class <CODE>Ty</CODE> has no virtual functions</LI>
<LI>the class <CODE>Ty</CODE> has no virtual bases</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial copy constructors</LI>
<LI>the classes of all the non-static data members of class type have trivial copy constructors</LI>
<LI>the classes of all the non-static data members of type array of class have trivial copy constructors</LI>
</UL>

<H2><CODE><A NAME="has_trivial_default_constructor">has_trivial_default_constructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_default_constructor</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a trivial constructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>default constructor</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is an implicitly declared default constructor</LI>
<LI>the class <CODE>Ty</CODE> has no virtual functions</LI>
<LI>the class <CODE>Ty</CODE> has no virtual bases</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial constructors</LI>
<LI>the classes of all the non-static data members of class type have trivial constructors</LI>
<LI>the classes of all the non-static data members of type array of class have trivial constructors</LI>
</UL>

<H2><CODE><A NAME="has_trivial_destructor">has_trivial_destructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_trivial_destructor</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a trivial destructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>destructor</B> for a class <CODE>Ty</CODE> is <B>trivial</B> if:</P>

<UL>
<LI>it is an implicitly declared destructor</LI>
<LI>all the direct bases of the class <CODE>Ty</CODE> have trivial destructors</LI>
<LI>the classes of all the non-static data members of class type have trivial destructors</LI>
<LI>the classes of all the non-static data members of type array of class have trivial destructors</LI>
</UL>

<H2><CODE><A NAME="has_virtual_destructor">has_virtual_destructor</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>has_virtual_destructor</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has a virtual destructor,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="integral_constant">integral_constant</A></CODE></H2>

<PRE>template&lt;class Ty, Ty v&gt;
    struct <B>integral_constant</B> {
        static const Ty <B>value</B> = v;
        typedef Ty <B>value_type</B>;
        typedef integral_constant&lt;Ty, v&gt; <B>type</B>;
        };</PRE>

<P>The template class, when specialized with an integral type and a value of
that type, represents an object that holds a constant of that integral
type with the specified value.</P>

<H2><CODE><A NAME="is_abstract">is_abstract</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_abstract</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a class that has at least one pure virtual function,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_arithmetic">is_arithmetic</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_arithmetic</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
an arithmetic type, that is, an <A HREF="#integral type">integral type</A>
or a <A HREF="#floating point type">floating point type</A>,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_array">is_array</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_array</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
an array type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_base_of">is_base_of</A></CODE></H2>

<PRE>template&lt;class Base, class Derived&gt;
    struct <B>is_base_of</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Base</CODE> is
a base class of the type <CODE>Derived</CODE>,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_class">is_class</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_class</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a type defined as a <CODE>class</CODE> or a <CODE>struct</CODE>,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_compound">is_compound</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_compound</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds false">holds false</A> if the type <CODE>Ty</CODE> is
a scalar type (that is, if <CODE><A HREF="#is_scalar">is_scalar</A>&lt;Ty&gt;</CODE>
<A HREF="#holds true">holds true</A>),
otherwise it <A HREF="#holds true">holdstrue</A>.
Thus, the predicate holds true
if <CODE>Ty</CODE> is an array type, a function type, a pointer to <CODE>void</CODE> or
an object or a function, a reference, a class, a union, an enumeration, or
a pointer to non-static class member,
or a <CODE>cv-qualified</CODE> form of one of them.</P>

<H2><CODE><A NAME="is_const">is_const</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_const</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if <CODE>Ty</CODE> is
<CODE>const-qualified</CODE>.</P>

<H2><CODE><A NAME="is_convertible">is_convertible</A></CODE></H2>

<PRE>template&lt;class From, class To&gt;
    struct <B>is_convertible</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the expression <CODE>To to = from;</CODE>,
where <CODE>from</CODE> is an object of type <CODE>From</CODE>, is well-formed.</P>

<H2><CODE><A NAME="is_empty">is_empty</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_empty</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is an
empty class, otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_enum">is_enum</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_enum</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
an enumeration type or a <CODE>cv-qualified</CODE> form of an enumeration type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_floating_point">is_floating_point</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_floating_point</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a floating point type or a <CODE>cv-qualified</CODE> form of a floating point type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <A NAME="floating point type">floating point type</A> is one of
<CODE>float</CODE>, <CODE>double</CODE>, or <CODE>long double</CODE>.</P>

<H2><CODE><A NAME="is_function">is_function</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_function</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a function type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_fundamental">is_fundamental</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_fundamental</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is a
fundamental type, that is, <CODE>void</CODE>,
an <A HREF="#integral type">integral type</A>,
an <A HREF="#floating point type">floating point type</A>,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_integral">is_integral</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_integral</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
one of the integral types, or a <CODE>cv-qualified</CODE> form of one
of the integral types, otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>An <A NAME="integral type">integral type</A> is one of
<CODE>bool</CODE>,
<CODE>char</CODE>,
<CODE>unsigned char</CODE>,
<CODE>signed char</CODE>,
<CODE>wchar_t</CODE>,
<CODE>short</CODE>,
<CODE>unsigned short</CODE>,
<CODE>int</CODE>,
<CODE>unsigned int</CODE>,
<CODE>long</CODE>,
and <CODE>unsigned long</CODE>.
In addition, with compilers that provide them, an integral type
can be one of
<CODE>long long</CODE>,
<CODE>unsigned long long</CODE>,
<CODE>__int64</CODE>,
and <CODE>unsigned __int64</CODE>.</P>

<H2><CODE><A NAME="is_lvalue_reference">is_lvalue_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_lvalue_reference</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a reference to an object or to a function,
otherwise it <A HREF="#holds false">holds false</A>.
Note that it may <B>not</B> be an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>.</P>

<H2><CODE><A NAME="is_member_function_pointer">is_member_function_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_member_function_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a pointer to member function or a <CODE>cv-qualified</CODE> pointer to
member function,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_member_object_pointer">is_member_object_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_member_object_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a pointer to member object or a <CODE>cv-qualified</CODE> pointer to member object,
otherwise it <A HREF="#holds false">holds false</A>. Note that <CODE>is_member_object_pointer</CODE>
holds false if <CODE>Ty</CODE> is a pointer to member function.</P>

<H2><CODE><A NAME="is_member_pointer">is_member_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_member_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a pointer to member function or a pointer to member object,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_object">is_object</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_object</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds false">holds false</A> if the type <CODE>Ty</CODE> is
a reference type, a function type, or void,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise <A HREF="#holds true">holds true</A>.</P>

<H2><CODE><A NAME="is_pod">is_pod</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_pod</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a scalar type, a POD aggregate type,
or a <CODE>cv-qualified</CODE> form of one of them,
or an array of such a type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>A <B>POD aggregate</B> type is a class, struct, or union whose
non-static data members are all scalar types or POD aggregates, and
that has no references, no user-defined copy assignment operator, and no
user-defined destructor.</P>

<H2><CODE><A NAME="is_pointer">is_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a pointer to <CODE>void</CODE>, a pointer to an object, or a pointer to a function,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>. Note that <CODE>is_pointer</CODE>
holds false if <CODE>Ty</CODE> is a pointer to member or a pointer to
member function.</P>

<H2><CODE><A NAME="is_polymorphic">is_polymorphic</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_polymorphic</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE>
is a class that declares or inherits a virtual function,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_reference">is_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_reference</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a reference to an object or to a function,
otherwise it <A HREF="#holds false">holds false</A>.
Beginning with <B>C++0X</B>, it may also be an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>.</P>

<H2><CODE><A NAME="is_rvalue_reference">is_rvalue_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_rvalue_reference</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is an
<A HREF="lib_cpp.html#rvalue references">rvalue reference</A>.</P>

<H2><CODE><A NAME="is_same">is_same</A></CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;
    struct <B>is_same</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the types <CODE>Ty1</CODE>
and <CODE>Ty2</CODE> are the same type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_scalar">is_scalar</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_scalar</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
an <A HREF="#integral type">integral type</A>,
a <A HREF="#floating point type">floating point type</A>,
an enumeration type, a pointer type, or a pointer to member type,
or a <CODE>cv-qualified</CODE> form of one of them,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_signed">is_signed</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_signed</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a signed <A HREF="#integral type">integral type</A>
or a <CODE>cv-qualified</CODE> signed integral type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>Beginning with <B>C++0X</B> it may also be
a <A HREF="#floating point type">floating point type</A>,
an enumeration, or a <CODE>cv-qualified</CODE> form of one of these types.
A type is considered signed if <CODE>Ty(-1) &lt; Ty(0)</CODE>.</P>

<H2><CODE><A NAME="is_standard_layout">is_standard_layout</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_standard_layout</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE>
is a class that has a standard layout of member objects in memory,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_trivial">is_trivial</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_trivial</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE>
is a trivial class,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_union">is_union</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_union</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
a union type or a <CODE>cv-qualified</CODE> form of a union type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_unsigned">is_unsigned</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_unsigned</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
an unsigned <A HREF="#integral type">integral type</A>
or a <CODE>cv-qualified</CODE> unsigned integral type,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<P>Beginning with <B>C++0X</B> it may also be
an enumeration, or a <CODE>cv-qualified</CODE> form of such a type.
A type is considered unsigned if <CODE>Ty(0) &lt; Ty(-1)</CODE>.</P>

<H2><CODE><A NAME="is_void">is_void</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_void</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if the type <CODE>Ty</CODE> is
<CODE>void</CODE> or a <CODE>cv-qualified</CODE> form of <CODE>void</CODE>,
otherwise it <A HREF="#holds false">holds false</A>.</P>

<H2><CODE><A NAME="is_volatile">is_volatile</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>is_volatile</B>;</PRE>

<P>An instance of the <A HREF="#type predicate">type predicate</A>
<A HREF="#holds true">holds true</A> if <CODE>Ty</CODE> is
<CODE>volatile-qualified</CODE>.</P>

<H2><CODE><A NAME="make_signed">make_signed</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>make_signed</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE> if
<CODE><A HREF="#is_signed">is_signed</A>&lt;Ty&gt;</CODE>
<A HREF="#holds true">holds true</A>. Otherwise it is the smallest signed type
<CODE>STy</CODE> for which <CODE>sizeof (Ty) &lt;= sizeof (STy)</CODE>.</P>

<H2><CODE><A NAME="make_unsigned">make_unsigned</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>make_unsigned</B>; <B>[added with C++0X]</B></PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is <CODE>Ty</CODE> if
<CODE><A HREF="#is_unsigned">is_unsigned</A>&lt;Ty&gt;</CODE>
<A HREF="#holds true">holds true</A>. Otherwise it is the smallest unsigned type
<CODE>UTy</CODE> for which <CODE>sizeof (Ty) &lt;= sizeof (UTy)</CODE>.</P>

<H2><CODE><A NAME="rank">rank</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>rank</B>;</PRE>

<P>The <A HREF="#type query">type query</A>
<A HREF="#holds the value">holds the value</A> of the number of dimensions of
the array type <CODE>Ty</CODE>, or 0 if <CODE>Ty</CODE> is not an array type.</P>

<H2><CODE><A NAME="remove_all_extents">remove_all_extents</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_all_extents</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
the element type of the array type <CODE>Ty</CODE> with all array dimensions
removed, or <CODE>Ty</CODE> if <CODE>Ty</CODE> is not an array type.</P>

<H2><CODE><A NAME="remove_extent">remove_extent</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_extent</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>Ty1[N]</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="remove_const">remove_const</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_const</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>const Ty1</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="remove_cv">remove_cv</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_cv</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>const Ty1</CODE>,
<CODE>volatile Ty1</CODE>, or <CODE>const volatile Ty1</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="remove_pointer">remove_pointer</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_pointer</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>Ty1*</CODE>,
<CODE>Ty1* const</CODE>, <CODE>Ty1* volatile</CODE>, or <CODE>Ty1* const volatile</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="remove_reference">remove_reference</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_reference</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>Ty1&amp;</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="remove_volatile">remove_volatile</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>remove_volatile</B>;</PRE>

<P>An instance of the <A HREF="#type modifier">type modifier</A>
holds a <A HREF="#modified-type">modified-type</A> that is
<CODE>Ty1</CODE> when <CODE>Ty</CODE> is of the form <CODE>volatile Ty1</CODE>,
otherwise <CODE>Ty</CODE>.</P>

<H2><CODE><A NAME="true_type">true_type</A></CODE></H2>

<PRE>typedef integral_constant&lt;bool, true&gt; <B>true_type</B>;</PRE>

<P>The type is a synonym for a specialization of the template
<CODE>integral_constant</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<A HREF="_index.html">Index</A>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by Dinkumware, Ltd. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
