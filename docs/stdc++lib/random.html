<HTML><HEAD><TITLE>&lt;random&gt;</TITLE></HEAD><BODY>

<H1><CODE><A NAME="&lt;random&gt;">&lt;random&gt;</A></CODE></H1>

<P>[added with
<A HREF="index.html#TR1">TR1</A>]</P><HR>

<P><B><CODE><A HREF="#bernoulli_distribution">bernoulli_distribution</A>
&#183; <A HREF="#binomial_distribution">binomial_distribution</A>
&#183; <A HREF="#discard_block">discard_block</A>
&#183; <A HREF="#exponential_distribution">exponential_distribution</A>
&#183; <A HREF="#gamma_distribution">gamma_distribution</A>
&#183; <A HREF="#geometric_distribution">geometric_distribution</A>
&#183; <A HREF="#linear_congruential">linear_congruential</A>
&#183; <A HREF="#mersenne_twister">mersenne_twister</A>
&#183; <A HREF="#minstd_rand0">minstd_rand0</A>
&#183; <A HREF="#minstd_rand">minstd_rand</A>
&#183; <A HREF="#mt19937">mt19937</A>
&#183; <A HREF="#normal_distribution">normal_distribution</A>
&#183; <A HREF="#operator_ne">operator!=</A>
&#183; <A HREF="#operator_eq">operator==</A>
&#183; <A HREF="#operator_lsh">operator&lt;&lt;</A>
&#183; <A HREF="#operator_rsh">operator&gt;&gt;</A>
&#183; <A HREF="#poisson_distribution">poisson_distribution</A>
&#183; <A HREF="#random_device">random_device</A>
&#183; <A HREF="#ranlux_base_01">ranlux_base_01</A>
&#183; <A HREF="#ranlux3">ranlux3</A>
&#183; <A HREF="#ranlux3_01">ranlux3_01</A>
&#183; <A HREF="#ranlux4">ranlux4</A>
&#183; <A HREF="#ranlux4_01">ranlux4_01</A>
&#183; <A HREF="#ranlux64_base_01">ranlux64_base_01</A>
&#183; <A HREF="#subtract_with_carry">subtract_with_carry</A>
&#183; <A HREF="#subtract_with_carry_01">subtract_with_carry_01</A>
&#183; <A HREF="#uniform_int">uniform_int</A>
&#183; <A HREF="#uniform_real">uniform_real</A>
&#183; <A HREF="#variate_generator">variate_generator</A>
&#183; <A HREF="#xor_combine">xor_combine</A>
</CODE></B></P>

<P><B><CODE><A HREF="#cauchy_distribution">cauchy_distribution</A>
&#183; <A HREF="#chi_squared_distribution">chi_squared_distribution</A>
&#183; <A HREF="#default_random_engine">default_random_engine</A>
&#183; <A HREF="#discard_block_engine">discard_block_engine</A>
&#183; <A HREF="#discrete_distribution">discrete_distribution</A>
&#183; <A HREF="#extreme_value_distribution">extreme_value_distribution</A>
&#183; <A HREF="#fisher_f_distribution">fisher_f_distribution</A>
&#183; <A HREF="#generate_canonical">generate_canonical</A>
&#183; <A HREF="#independent_bits_engine">independent_bits_engine</A>
&#183; <A HREF="#knuth_b">knuth_b</A>
&#183; <A HREF="#linear_congruential_engine">linear_congruential_engine</A>
&#183; <A HREF="#lognormal_distribution">lognormal_distribution</A>
&#183; <A HREF="#mersenne_twister_engine">mersenne_twister_engine</A>
&#183; <A HREF="#mt19937_64">mt19937_64</A>
&#183; <A HREF="#negative_binomial_distribution">negative_binomial_distribution</A>
&#183; <A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A>
&#183; <A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A>
&#183; <A HREF="#ranlux24">ranlux24</A>
&#183; <A HREF="#ranlux24_base">ranlux24_base</A>
&#183; <A HREF="#ranlux48">ranlux48</A>
&#183; <A HREF="#ranlux48_base">ranlux48_base</A>
&#183; <A HREF="#seed_seq">seed_seq</A>
&#183; <A HREF="#shuffle_order_engine">shuffle_order_engine</A>
&#183; <A HREF="#student_t_distribution">student_t_distribution</A>
&#183; <A HREF="#subtract_with_carry_engine">subtract_with_carry_engine</A>
&#183; <A HREF="#uniform_int_distribution">uniform_int_distribution</A>
&#183; <A HREF="#uniform_real_distribution">uniform_real_distribution</A>
&#183; <A HREF="#weibull_distribution">weibull_distribution</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="index.html#TR1">TR1</A>
header <B><CODE>&lt;random&gt;</CODE></B> to define a host of
<A HREF="lib_rand.html#random number generator">random number generators</A>.</P>

<PRE>namespace std {
    namespace tr1 {
    // UTILITIES
template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <B><A HREF="#generate_canonical">generate_canonical</A></B>(Engine&amp; gen); <B>[added with C++0X]</B>
class <B><A HREF="#seed_seq">seed_seq</A></B>; <B>[added with C++0X]</B>

template&lt;class Engine,
    class Dist&gt;
    class <B><A HREF="#variate_generator">variate_generator</A></B>;

    // SIMPLE ENGINES
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B><A HREF="#linear_congruential">linear_congruential</A></B>;
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <B><A HREF="#mersenne_twister">mersenne_twister</A></B>;
template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry">subtract_with_carry</A></B>;
template&lt;class RealType,
    int W, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry_01">subtract_with_carry_01</A></B>;
class <B><A HREF="#random_device">random_device</A></B>;

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B><A HREF="#linear_congruential_engine">linear_congruential_engine</A></B>; <B>[added with C++0X]</B>
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U,
    UIntType D, int S,
    UIntType B, int T,
    UIntType C, int L,
    UIntType F&gt;
    class <B><A HREF="#mersenne_twister_engine">mersenne_twister_engine</A></B>; <B>[added with C++0X]</B>
template&lt;class IntType,
    int W, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry_engine">subtract_with_carry_engine</A></B>; <B>[added with C++0X]</B>

    // COMPOUND ENGINES
template&lt;class Engine,
    int P, int R&gt;
    class <B><A HREF="#discard_block">discard_block</A></B>;
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <B><A HREF="#xor_combine">xor_combine</A></B>;

template&lt;class Engine,
    size_t P, size_t R&gt;
    class <B><A HREF="#discard_block_engine">discard_block_engine</A></B>; <B>[added with C++0X]</B>
template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <B><A HREF="#independent_bits_engine">independent_bits_engine</A></B>; <B>[added with C++0X]</B>
template&lt;class Engine,
    size_t K&gt;
    class <B><A HREF="#shuffle_order_engine">shuffle_order_engine</A></B>; <B>[added with C++0X]</B>

    // ENGINES WITH PREDEFINED PARAMETERS
typedef linear_congruential&lt;<I>ui-type</I>, 16807, 0, 2147483647&gt; <B><A HREF="#minstd_rand0">minstd_rand0</A></B>;
typedef linear_congruential&lt;<I>ui-type</I>, 48271, 0, 2147483647&gt; <B><A HREF="#minstd_rand">minstd_rand</A></B>;
typedef mersenne_twister&lt;<I>ui-type</I>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <B><A HREF="#mt19937">mt19937</A></B>;
typedef mersenne_twister_engine&lt;<I>ui-type</I>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0x0ff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <B><A HREF="#mt19937_64">mt19937_64</A></B> <B>[added with C++0X]</B>;
typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <B><A HREF="#ranlux_base_01">ranlux_base_01</A></B>;
typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <B><A HREF="#ranlux64_base_01">ranlux64_base_01</A></B>;
typedef discard_block&lt;subtract_with_carry&lt;<I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    223, 24&gt; <B><A HREF="#ranlux3">ranlux3</A></B>;
typedef discard_block&lt;subtract_with_carry&lt;<I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <B><A HREF="#ranlux4">ranlux4</A></B>;
typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <B><A HREF="#ranlux3_01">ranlux3_01</A></B>;
typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <B><A HREF="#ranlux4_01">ranlux4_01</A></B>;

typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <B><A HREF="#knuth_b">knuth_b</A></B>; <B>[added with C++0X]</B>
typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 24, 10, 24&gt;
    <B><A HREF="#ranlux24_base">ranlux24_base</A></B>; <B>[added with C++0X]</B>
typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <B><A HREF="#ranlux24">ranlux24</A></B>; <B>[added with C++0X]</B>
typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 48, 5, 12&gt;
    <B><A HREF="#ranlux48_base">ranlux48_base</A></B>; <B>[added with C++0X]</B>
typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <B><A HREF="#ranlux48">ranlux48</A></B>; <B>[added with C++0X]</B>

typedef Rand <B><A HREF="#default_random_engine">default_random_engine</A></B>; <B>[added with C++0X]</B>

    // DISTRIBUTIONS
template&lt;class RealType = double&gt;
    class <B><A HREF="#bernoulli_distribution">bernoulli_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#binomial_distribution">binomial_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#geometric_distribution">geometric_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#poisson_distribution">poisson_distribution</A></B>;
template&lt;class IntType = int&gt;
    class <B><A HREF="#uniform_int">uniform_int</A></B>;

template&lt;class RealType = double&gt;
    class <B><A HREF="#exponential_distribution">exponential_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#gamma_distribution">gamma_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#normal_distribution">normal_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#uniform_real">uniform_real</A></B>;

template&lt;class IntType = int&gt;
    class <B><A HREF="#discrete_distribution">discrete_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class IntType = int&gt;
    class <B><A HREF="#negative_binomial_distribution">negative_binomial_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class IntType = int&gt;
    class <B><A HREF="#uniform_int_distribution">uniform_int_distribution</A></B>; <B>[added with C++0X]</B>

template&lt;class RealType = double&gt;
    class <B><A HREF="#cauchy_distribution">cauchy_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#chi_squared_distribution">chi_squared_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#extreme_value_distribution">extreme_value_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#fisher_f_distribution">fisher_f_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#lognormal_distribution">lognormal_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#student_t_distribution">student_t_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#uniform_real_distribution">uniform_real_distribution</A></B>; <B>[added with C++0X]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#weibull_distribution">weibull_distribution</A></B>; <B>[added with C++0X]</B>

    // OPERATORS
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++0X]</B>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++0X]</B>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, R&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);
    }  // namespace tr1
using tr1::bernoulli_distribution; <B>[added with C++0X]</B>
using tr1::binomial_distribution;
using tr1::discard_block; using tr1::exponential_distribution;
using tr1::gamma_distribution; using tr1::geometric_distribution;
using tr1::linear_congruential; using tr1::mersenne_twister;
using tr1::minstd_rand; using tr1::minstd_rand0;
using tr1::mt19937; using tr1::normal_distribution;
using tr1::poisson_distribution; using tr1::random_device;
using tr1::ranlux4; using tr1::ranlux3;
using tr1::ranlux3_01; using tr1::ranlux4;
using tr1::ranlux4_01; using tr1::ranlux64_base_01;
using tr1::ranlux_base_01; using tr1::subtract_with_carry;
using tr1::subtract_with_carry_01; using tr1::uniform_int;
using tr1::uniform_real; using tr1::variate_generator;
using tr1::xor_combine;

using tr1::cauchy_distribution; using tr1::chi_squared_distribution;
using tr1::discard_block_engine; using tr1::discrete_distribution;
using tr1::extreme_value_distribution; using tr1::fisher_f_distribution;
using tr1::generate_canonical;
using tr1::knuth_b; using tr1::independent_bits_engine;
using tr1::linear_congruential_engine; using tr1::lognormal_distribution;
using tr1::mersenne_twister_engine; using tr1::mt19937_64; 
using tr1::negative_binomial_distribution;
using tr1::piecewise_constant_distribution; piecewise_linear_distribution;
using tr1::ranlux24; using tr1::ranlux24_base; using tr1::ranlux48;
using tr1::ranlux48_base; using tr1::seed_seq; 
using tr1::shuffle_order_engine; using tr1::student_t_distribution;
using tr1::subtract_with_carry_engine; 
using tr1::uniform_int_distribution; using tr1::uniform_real_distribution;
using tr1::weibull_distribution;
}  // namespace std</PRE>

<H2><CODE><A NAME="bernoulli_distribution">bernoulli_distribution</A></CODE></H2>

<PRE>class <B>bernoulli_distribution</B> {
public:
    typedef int <B><A HREF="#bernoulli_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    struct <B><A HREF="#bernoulli_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#bernoulli_distribution::bernoulli_distribution">bernoulli_distribution</A></B>(double p0 = 0.5);
    explicit <B><A HREF="#bernoulli_distribution::bernoulli_distribution">bernoulli_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    double <B><A HREF="#bernoulli_distribution::p">p</A></B>() const;
    param_type <B><A HREF="#bernoulli_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#bernoulli_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#bernoulli_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#bernoulli_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#bernoulli_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#bernoulli_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#bernoulli_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    double <B>stored_p</B>;  <I>// exposition only</I>
    };</PRE>

<P>The class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of type <CODE>bool</CODE>, returning <CODE>true</CODE> with a
probability given by the argument to the constructor.</P>

<H3><CODE><A NAME="bernoulli_distribution::bernoulli_distribution">bernoulli_distribution::bernoulli_distribution</A></CODE></H3>

<PRE><B>explicit bernoulli_distribution</B>(double p0 = 0.5);
explicit <B>bernoulli_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &le; p0 &amp;&amp; p0 &le; 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::input_type">bernoulli_distribution::input_type</A></CODE></H3>

<PRE>typedef int <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for <CODE>int</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::max">bernoulli_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns <CODE>true</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::min">bernoulli_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns <CODE>false</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::operator()">bernoulli_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integer values and returns <CODE>true</CODE>
with probability given by the stored value <CODE>stored_p</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::p">bernoulli_distribution::p</A></CODE></H3>

<PRE>double <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::param">bernoulli_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution::param_type">bernoulli_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef bernoulli_distribution distribution_type;

    param_type(double p0 = 0.5);
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="bernoulli_distribution::reset">bernoulli_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="bernoulli_distribution::result_type">bernoulli_distribution::result_type</A></CODE></H3>

<PRE>typedef bool <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>bool</CODE>.</P>

<H2><CODE><A NAME="binomial_distribution">binomial_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++0X]</B>
    class <B>binomial_distribution</B> {
public:
    typedef T1 <B><A HREF="#binomial_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef IntType <B><A HREF="#binomial_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#binomial_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#binomial_distribution::binomial_distribution">binomial_distribution</A></B>(result_type t0 = 1,
        RealType p0 = RealType(0.5));
    explicit <B><A HREF="#binomial_distribution::binomial_distribution">binomial_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#binomial_distribution::t">t</A></B>() const;
    RealType <B><A HREF="#binomial_distribution::p">p</A></B>() const;
    param_type <B><A HREF="#binomial_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#binomial_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#binomial_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#binomial_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#binomial_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#binomial_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#binomial_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    result_type <B>stored_t</B>;  <I>// exposition only</I>
    RealType <B>stored_p</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed with a binomial
distribution.</P>

<H3><CODE><A NAME="binomial_distribution::binomial_distribution">binomial_distribution::binomial_distribution</A></CODE></H3>

<PRE><B>binomial_distribution</B>(result_type t0 = 1,
    RealType p0 = RealType(0.5));
explicit <B>binomial_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt;= t0 &amp;&amp; 0.0 &lt;= p0 &amp;&amp; p0 &lt;= 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE> and whose stored value <CODE>stored_t</CODE> holds
the value <CODE>t0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::input_type">binomial_distribution::input_type</A></CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::max">binomial_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::min">binomial_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::operator()">binomial_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="binomial_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::p">binomial_distribution::p</A></CODE></H3>

<PRE>RealType <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::param">binomial_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::param_type">binomial_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(result_type t0 = 1, RealType p0 = RealType(0.5));
    result_type t() const;
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="binomial_distribution::reset">binomial_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="binomial_distribution::result_type">binomial_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution::t">binomial_distribution::t</A></CODE></H3>

<PRE>result_type <B>t</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_t</CODE>.</P>

<H2><CODE><A NAME="cauchy_distribution">cauchy_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>cauchy_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#cauchy_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#cauchy_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#cauchy_distribution::cauchy_distribution">cauchy_distribution</A></B>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#cauchy_distribution::cauchy_distribution">cauchy_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#cauchy_distribution::a">a</A></B>() const;
    result_type <B><A HREF="#cauchy_distribution::b">b</A></B>() const;
    param_type <B><A HREF="#cauchy_distribution::param">param</A></B>() const;
    void <B><A HREF="#cauchy_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#cauchy_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#cauchy_distribution::max">max</A></B>() const;
    void <B><A HREF="#cauchy_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#cauchy_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#cauchy_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Cauchy distribution.</P>

<H3><CODE><A NAME="cauchy_distribution::a">cauchy_distribution::a</A></CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::b">cauchy_distribution::b</A></CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::cauchy_distribution">cauchy_distribution::cauchy_distribution</A></CODE></H3>

<PRE><B>cauchy_distribution</B>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <B>cauchy_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::max">cauchy_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::min">cauchy_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::operator()">cauchy_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="cauchy_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::param">cauchy_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution::param_type">cauchy_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef cauchy_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="cauchy_distribution::reset">cauchy_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="cauchy_distribution::result_type">cauchy_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="chi_squared_distribution">chi_squared_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>chi_squared_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#chi_squared_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#chi_squared_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#chi_squared_distribution::chi_squared_distribution">chi_squared_distribution</A></B>(RealType n0 = 1);
    explicit <B><A HREF="#chi_squared_distribution::chi_squared_distribution">chi_squared_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#chi_squared_distribution::n">n</A></B>() const;
    param_type <B><A HREF="#chi_squared_distribution::param">param</A></B>() const;
    void <B><A HREF="#chi_squared_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#chi_squared_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#chi_squared_distribution::max">max</A></B>() const;
    void <B><A HREF="#chi_squared_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#chi_squared_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#chi_squared_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a chi-squared distribution.</P>

<H3><CODE><A NAME="chi_squared_distribution::chi_squared_distribution">chi_squared_distribution::chi_squared_distribution</A></CODE></H3>

<PRE><B>chi_squared_distribution</B>(RealType n0 = 1);
explicit <B>chi_squared_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::max">chi_squared_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::min">chi_squared_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::n">chi_squared_distribution::n</A></CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::operator()">chi_squared_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="chi_squared_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::param">chi_squared_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution::param_type">chi_squared_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef chi_squared_distribution&lt;RealType&gt; distribution_type;

    param_type(int n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="chi_squared_distribution::reset">chi_squared_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="chi_squared_distribution::result_type">chi_squared_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="default_random_engine">default_random_engine</A></CODE></H2>

<PRE>typedef Rand <B>default_random_engine</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for <CODE>Rand</CODE>, a predefined
<A HREF="lib_rand.html#engine">engine</A>.</P>

<H2><CODE><A NAME="discard_block">discard_block</A></CODE></H2>

<PRE>template&lt;class Engine,
    int P, int R&gt;
    class <B>discard_block</B> {
public:
    typedef Engine <B><A HREF="#discard_block::base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#discard_block::result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#discard_block::block_size">block_size</A></B> = P;
    static constexpr int <B><A HREF="#discard_block::used_block">used_block</A></B> = R;

    <B><A HREF="#discard_block::discard_block">discard_block</A></B>();
    explicit <B><A HREF="#discard_block::discard_block">discard_block</A></B>(const base_type&amp; eng);
    template&lt;class Gen&gt;
        <B><A HREF="#discard_block::discard_block">discard_block</A></B>(Gen&amp; gen);
    void <B><A HREF="#discard_block::seed">seed</A></B>();
    template&lt;class Gen&gt;
        void <B><A HREF="#discard_block::seed">seed</A></B>(Gen&amp; gen);

    const base_type&amp; <B><A HREF="#discard_block::base">base</A></B>() const;
    result_type <B><A HREF="#discard_block::min">min</A></B>() const;
    result_type <B><A HREF="#discard_block::max">max</A></B>() const;
    result_type <B><A HREF="#discard_block::operator()">operator()</A></B>();

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#compound engine">compound engine</A>
that produces values by discarding some of the values returned by its base engine. Each
cycle of the compound engine begins by returning <CODE>R</CODE> values successively produced
by the base engine and ends by discarding <CODE>P - R</CODE> such values.
The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>
followed by the number of calls to <CODE>operator()</CODE> that have occurred since the
beginning of the current cycle.</P>

<P>The value of the template argument <CODE>R</CODE> must be less than or
equal to the value of the template argument <CODE>P</CODE>.</P>

<H3><CODE><A NAME="discard_block::base">discard_block::base</A></CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="discard_block::base_type">discard_block::base_type</A></CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="discard_block::block_size">discard_block::block_size</A></CODE></H3>

<PRE>static constexpr int <B>block_size</B> = P;</PRE>

<P>The static const variable holds the value of the template argument <CODE>P</CODE>, the number
of values in each cycle.</P>

<H3><CODE><A NAME="discard_block::discard_block">discard_block::discard_block</A></CODE></H3>

<PRE><B>discard_block</B>();
explicit <B>discard_block</B>(const base_type&amp; eng);
template&lt;class Gen&gt;
    <B>discard_block</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs a <CODE>discard_block</CODE> object with a default-initialized
engine. The second contructor constructs a <CODE>discard_block</CODE> object with a copy of an
engine object. The third constructor constucts a <CODE>discard_block</CODE> object with an engine
initialized from a generator.</P>

<H3><CODE><A NAME="discard_block::max">discard_block::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_eng.max()</CODE>.</P>

<H3><CODE><A NAME="discard_block::min">discard_block::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_eng.min()</CODE>.</P>

<H3><CODE><A NAME="discard_block::operator()">discard_block::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="discard_block::result_type">discard_block::result_type</A></CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="discard_block::seed">discard_block::seed</A></CODE></H3>

<PRE>void <B>seed</B>();
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A>
calls <CODE>stored_eng.seed()</CODE> and sets <CODE>count</CODE> to 0.
The second seed function calls <CODE>stored_eng.seed(gen)</CODE>
and sets <CODE>count</CODE> to 0.</P>

<H3><CODE><A NAME="discard_block::used_block">discard_block::used_block</A></CODE></H3>

<PRE>static constexpr int <B>used_block</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>, the number
of values to return at the beginning of each cycle.</P>

<H2><CODE><A NAME="discard_block_engine">discard_block_engine</A></CODE></H2>

<PRE>template&lt;class Engine,
    int P, int R&gt;
    class <B>discard_block_engine</B> { <B>[added with C++0X]</B>
public:
    typedef Engine <B><A HREF="#discard_block_engine::base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#discard_block_engine::result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#discard_block_engine::block_size">block_size</A></B> = P;
    static constexpr int <B><A HREF="#discard_block_engine::used_block">used_block</A></B> = R;

    <B><A HREF="#discard_block_engine::discard_block_engine">discard_block_engine</A></B>();
    explicit <B><A HREF="#discard_block_engine::discard_block_engine">discard_block_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#discard_block_engine::discard_block_engine">discard_block_engine</A></B>(result_type x0);
    explicit <B><A HREF="#discard_block_engine::discard_block_engine">discard_block_engine</A></B>(seed_seq&amp; seq);
    void <B><A HREF="#discard_block_engine::seed">seed</A></B>();
    void <B><A HREF="#discard_block_engine::seed">seed</A></B>(result_type x0);
    void <B><A HREF="#discard_block_engine::seed">seed</A></B>(seed_seq& seq);

    const base_type&amp; <B><A HREF="#discard_block_engine::base">base</A></B>() const;
    static constexpr result_type <B><A HREF="#discard_block_engine::min">min</A></B>();
    static constexpr result_type <B><A HREF="#discard_block_engine::max">max</A></B>();
    result_type <B><A HREF="#discard_block_engine::operator()">operator()</A></B>();
    void <B><A HREF="#discard_block_engine::discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#compound engine">compound engine</A>
that produces values by discarding some of the values returned by its base engine. Each
cycle of the compound engine begins by returning <CODE>R</CODE> values successively produced
by the base engine and ends by discarding <CODE>P - R</CODE> such values.
The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>
followed by the number of calls to <CODE>operator()</CODE> that have occurred since the
beginning of the current cycle.</P>

<P>The value of the template argument <CODE>R</CODE> must be less than or
equal to the value of the template argument <CODE>P</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine::base">discard_block_engine::base</A></CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="discard_block_engine::base_type">discard_block_engine::base_type</A></CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="discard_block_engine::block_size">discard_block_engine::block_size</A></CODE></H3>

<PRE>static constexpr int <B>block_size</B> = P;</PRE>

<P>The static const variable holds the value of the template argument <CODE>P</CODE>, the number
of values in each cycle.</P>

<H3><CODE><A NAME="discard_block_engine::discard">discard_block_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="discard_block_engine::discard_block_engine">discard_block_engine::discard_block_engine</A></CODE></H3>

<PRE><B>discard_block_engine</B>();
explicit <B>discard_block_engine</B>(const base_type&amp; eng);
explicit <B>discard_block_engine</B>(result_type x0);
explicit <B>discard_block_engine</B>(seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>discard_block_engine</CODE> object with a default-initialized
engine. The second contructor constructs a <CODE>discard_block_engine</CODE> object with a copy of an
engine object. The third constructor constucts a <CODE>discard_block_engine</CODE> object with its engine
initialized by <CODE>stored_engine(x0)</CODE>. The fourth constructor constucts a
<CODE>discard_block_engine</CODE> object with its engine initialized by
<CODE>stored_engine(seq)</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine::max">discard_block_engine::max</A></CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine::min">discard_block_engine::min</A></CODE></H3>

<PRE>static result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine::operator()">discard_block_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="discard_block_engine::result_type">discard_block_engine::result_type</A></CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine::seed">discard_block_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A>
calls <CODE>stored_eng.seed()</CODE> and sets <CODE>count</CODE> to 0.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>
and sets <CODE>count</CODE> to 0.
The second seed function calls <CODE>stored_eng.seed(seq)</CODE>
and sets <CODE>count</CODE> to 0.</P>

<H3><CODE><A NAME="discard_block_engine::used_block">discard_block_engine::used_block</A></CODE></H3>

<PRE>static constexpr int <B>used_block</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>, the number
of values to return at the beginning of each cycle.</P>

<H2><CODE><A NAME="discrete_distribution">discrete_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>discrete_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef IntType <B><A HREF="#discrete_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#discrete_distribution::param_type">param_type</A></B>;

    <B><A HREF="#discrete_distribution::discrete_distribution">discrete_distribution</A></B>();
    <B><A HREF="#discrete_distribution::discrete_distribution">discrete_distribution</A></B>(initializer_list&lt;double&gt; init);
    explicit <B><A HREF="#discrete_distribution::discrete_distribution">discrete_distribution</A></B>(const param_type&amp; par0);
    template&lt;class Fn&gt;
        <B><A HREF="#discrete_distribution::discrete_distribution">discrete_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#discrete_distribution::discrete_distribution">discrete_distribution</A></B>(const param_type&amp; par0);

    std::vector&lt;double&gt; <B><A HREF="#discrete_distribution::probabilities">probabilities</A></B>() const;
    param_type <B><A HREF="#discrete_distribution::param">param</A></B>() const;
    void <B><A HREF="#discrete_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#discrete_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#discrete_distribution::max">max</A></B>() const;
    void <B><A HREF="#discrete_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#discrete_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#discrete_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <B>stored_p</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed according to
a uniform-width histogram of probabilities.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE>discrete_distribution</CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="discrete_distribution::discrete_distribution">discrete_distribution::discrete_distribution</A></CODE></H3>

<PRE><B>discrete_distribution</B>();
<B>discrete_distribution</B>(initializer_list&lt;double&gt; init);
template&lt;class Fn&gt;
    <B>discrete_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>discrete_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements in <CODE>init</CODE>
are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
has one element with value 1.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>,
then normalized so that the sum of all elements is 1.
If the sequence is empty, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> uniform subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fourth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::max">discrete_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::min">discrete_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::operator()">discrete_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> in the range <CODE>[0, stored_p.size() - 1)</CODE>
occurring with probability <CODE>stored_p[i]</CODE> and all other values of <CODE>i</CODE>
occurring with probability zero.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::param">discrete_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::param_type">discrete_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef discrete_distribution&lt;IntType&gt; distribution_type;

    param_type();
    param_type(initializer_list&lt;double&gt; init);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);
    std::vector&lt;double&gt; probabilities() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="discrete_distribution::probabilities">discrete_distribution::probabilities</A></CODE></H3>

<PRE>std::vector&lt;double&gt; <B>probabilities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution::reset">discrete_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="discrete_distribution::result_type">discrete_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="exponential_distribution">exponential_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>exponential_distribution</B> {
public:
    typedef RealType <B><A HREF="#exponential_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef RealType <B><A HREF="#exponential_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#exponential_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#exponential_distribution::exponential_distribution">exponential_distribution</A></B>(result_type lambda0 = result_type(1.0));
    explicit <B><A HREF="#exponential_distribution::exponential_distribution">exponential_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#exponential_distribution::lambda">lambda</A></B>() const;
    param_type <B><A HREF="#exponential_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#exponential_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#exponential_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#exponential_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#exponential_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#exponential_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#exponential_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    result_type <B>stored_lambda</B>;   <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with an exponential
distribution.</P>

<H3><CODE><A NAME="exponential_distribution::exponential_distribution">exponential_distribution::exponential_distribution</A></CODE></H3>

<PRE><B>exponential_distribution</B>(result_type lambda0 = result_type(1.0));
explicit <B>exponential_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; lambda0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_lambda</CODE>
holds the value <CODE>lambda0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::input_type">exponential_distribution::input_type</A></CODE></H3>

<PRE>typedef RealType <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::lambda">exponential_distribution::lambda</A></CODE></H3>

<PRE>result_type <B>lambda</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_lambda</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::max">exponential_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::min">exponential_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::operator()">exponential_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="exponential_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::param">exponential_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution::param_type">exponential_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef exponential_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type lambda0 = result_type(1.0));
    result_type lambda() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="exponential_distribution::reset">exponential_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="exponential_distribution::result_type">exponential_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="extreme_value_distribution">extreme_value_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>extreme_value_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#extreme_value_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#extreme_value_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#extreme_value_distribution::extreme_value_distribution">extreme_value_distribution</A></B>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#extreme_value_distribution::extreme_value_distribution">extreme_value_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#extreme_value_distribution::a">a</A></B>() const;
    result_type <B><A HREF="#extreme_value_distribution::b">b</A></B>() const;
    param_type <B><A HREF="#extreme_value_distribution::param">param</A></B>() const;
    void <B><A HREF="#extreme_value_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#extreme_value_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#extreme_value_distribution::max">max</A></B>() const;
    void <B><A HREF="#extreme_value_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#extreme_value_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#extreme_value_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with an extreme-value (a.k.a. Gumbel Type I, log Weibull,
or Fisher-Tippett Type I) distribution.</P>

<H3><CODE><A NAME="extreme_value_distribution::a">extreme_value_distribution::a</A></CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::b">extreme_value_distribution::b</A></CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::extreme_value_distribution">extreme_value_distribution::extreme_value_distribution</A></CODE></H3>

<PRE><B>extreme_value_distribution</B>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <B>extreme_value_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::max">extreme_value_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::min">extreme_value_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::operator()">extreme_value_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="extreme_value_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::param">extreme_value_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution::param_type">extreme_value_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef extreme_value_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="extreme_value_distribution::reset">extreme_value_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="extreme_value_distribution::result_type">extreme_value_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="fisher_f_distribution">fisher_f_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>fisher_f_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#fisher_f_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#fisher_f_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#fisher_f_distribution::fisher_f_distribution">fisher_f_distribution</A></B>(RealType m0 = 1,
        RealType n0 = 1);
    explicit <B><A HREF="#fisher_f_distribution::fisher_f_distribution">fisher_f_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#fisher_f_distribution::m">m</A></B>() const;
    RealType <B><A HREF="#fisher_f_distribution::n">n</A></B>() const;
    param_type <B><A HREF="#fisher_f_distribution::param">param</A></B>() const;
    void <B><A HREF="#fisher_f_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#fisher_f_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#fisher_f_distribution::max">max</A></B>() const;
    void <B><A HREF="#fisher_f_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#fisher_f_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#fisher_f_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_m</B>;  <I>// exposition only</I>
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Fisher F distribution.</P>

<H3><CODE><A NAME="fisher_f_distribution::fisher_f_distribution">fisher_f_distribution::fisher_f_distribution</A></CODE></H3>

<PRE><B>fisher_f_distribution</B>(RealType m0 = 1,
    RealType n0 = 1);
explicit <B>fisher_f_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; m0
&amp;&amp; 0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_m</CODE>
holds the value <CODE>m0</CODE> and whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::m">fisher_f_distribution::m</A></CODE></H3>

<PRE>RealType <B>m</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_m</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::max">fisher_f_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::min">fisher_f_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::n">fisher_f_distribution::n</A></CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::operator()">fisher_f_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="fisher_f_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::param">fisher_f_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution::param_type">fisher_f_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef fisher_f_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType m0 = 1, RealType n0 = 1);
    RealType m() const;
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="fisher_f_distribution::reset">fisher_f_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="fisher_f_distribution::result_type">fisher_f_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="gamma_distribution">gamma_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>gamma_distribution</B> {
public:
    typedef T1 <B><A HREF="#gamma_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef RealType <B><A HREF="#gamma_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#gamma_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#gamma_distribution::gamma_distribution">gamma_distribution</A></B>(result_type alpha0 = result_type(1.0),
        result_type beta0 = result_type(1.0)); <B>[beta added with C++0X]</B>
    explicit <B><A HREF="#gamma_distribution::gamma_distribution">gamma_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#gamma_distribution::alpha">alpha</A></B>() const;
    result_type <B><A HREF="#gamma_distribution::beta">beta</A></B>() const; <B>[added with C++0X]</B>
    param_type <B><A HREF="#gamma_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#gamma_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#gamma_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#gamma_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#gamma_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#gamma_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#gamma_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    result_type <B>stored_alpha</B>;    <I>// exposition only</I>
    result_type <B>stored_beta</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a gamma distribution.</P>

<H3><CODE><A NAME="gamma_distribution::alpha">gamma_distribution::alpha</A></CODE></H3>

<PRE>result_type <B>alpha</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_alpha</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::beta">gamma_distribution::beta</A></CODE></H3>

<PRE>result_type <B>beta</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the stored value <CODE>stored_beta</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::gamma_distribution">gamma_distribution::gamma_distribution</A></CODE></H3>

<PRE><B>gamma_distribution</B>(result_type alpha0 = result_type(1.0));
    result_type beta0 = result_type(1.0)); <B>[beta added with C++0X]</B>
explicit <B>gamma_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; alpha0
&amp;&amp;0.0 &lt; beta0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_alpha</CODE>
holds the value <CODE>alpha0</CODE> and whose stored value <CODE>stored_beta</CODE>
holds the value <CODE>beta0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::input_type">gamma_distribution::input_type</A></CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::max">gamma_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::min">gamma_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::operator()">gamma_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="gamma_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::param">gamma_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution::param_type">gamma_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef gamma_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type alpha0 = result_type(1.0),
        RealType beta0 result_type(1.0));
    RealType alpha() const;
    RealType beta() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="gamma_distribution::reset">gamma_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="gamma_distribution::result_type">gamma_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="generate_canonical">generate_canonical</A></CODE></H2>

<PRE>template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <B>generate_canonical</B>(Engine&amp; gen); <B>[added with C++0X]</B></PRE>

<P>The template function calls <CODE>gen()</CODE> repeatedly and packs the returned
values into a floating-point value <CODE>x</CODE> of type <CODE>RealType</CODE> until it has
gathered the specified number of mantissa bits in <CODE>x</CODE>.
The specified number is the smaller of <CODE>bits</CODE> (which must be nonzero)
and the full number of mantissa bits in <CODE>RealType</CODE>. The first
call supplies the lowest-order bits. The function returns <CODE>x</CODE>.</P>

<H2><CODE><A NAME="geometric_distribution">geometric_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++0X]</B>
    class <B>geometric_distribution</B> {
public:
    typedef T1 <B><A HREF="#geometric_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef IntType <B><A HREF="#geometric_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#geometric_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#geometric_distribution::geometric_distribution">geometric_distribution</A></B>(RealType p0 = RealType(0.5));
    explicit <B><A HREF="#geometric_distribution::geometric_distribution">geometric_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    RealType <B><A HREF="#geometric_distribution::p">p</A></B>() const;
    param_type <B><A HREF="#geometric_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#geometric_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    void <B><A HREF="#geometric_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#geometric_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#geometric_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    RealType <B>stored_p</B>;          <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a geometric distribution.</P>

<H3><CODE><A NAME="geometric_distribution::geometric_distribution">geometric_distribution::geometric_distribution</A></CODE></H3>

<PRE><B>geometric_distribution</B>(RealType p0 = RealType(0.5));
explicit <B>geometric_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; p0 &amp;&amp; p0 &lt; 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE> holds
the value <CODE>p0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution::input_type">geometric_distribution::input_type</A></CODE></H3>

<PRE>typedef T1 <B>input_type</B>;</PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution::operator()">geometric_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="geometric_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution::p">geometric_distribution::p</A></CODE></H3>

<PRE>RealType <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution::param">geometric_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution::param_type">geometric_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType p0 = RealType(0.5));
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="geometric_distribution::reset">geometric_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="geometric_distribution::result_type">geometric_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="independent_bits_engine">independent_bits_engine</A></CODE></H2>

<PRE>template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <B>independent_bits_engine</B> { <B>[added with C++0X]</B>
public:
    typedef Engine <B><A HREF="#independent_bits_engine::base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#independent_bits_engine::result_type">result_type</A></B>;

    <B><A HREF="#independent_bits_engine::independent_bits_engine">independent_bits_engine</A></B>();
    explicit <B><A HREF="#independent_bits_engine::independent_bits_engine">independent_bits_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#independent_bits_engine::independent_bits_engine">independent_bits_engine</A></B>(result_type x0);
    explicit <B><A HREF="#independent_bits_engine::independent_bits_engine">independent_bits_engine</A></B>(seed_seq&amp; seq);
    void <B><A HREF="#independent_bits_engine::seed">seed</A></B>();
    void <B><A HREF="#independent_bits_engine::seed">seed</A></B>(result_type x0);
    void <B><A HREF="#independent_bits_engine::seed">seed</A></B>(seed_seq& seq);

    const base_type&amp; <B><A HREF="#independent_bits_engine::base">base</A></B>() const;
    static constexpr result_type <B><A HREF="#independent_bits_engine::min">min</A></B>();
    static constexpr result_type <B><A HREF="#independent_bits_engine::max">max</A></B>();
    result_type <B><A HREF="#independent_bits_engine::operator()">operator()</A></B>();
    void <B><A HREF="#independent_bits_engine::discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#compound engine">compound engine</A>
that produces values by repacking bits as needed from the values
returned by its base engine. Each resulting <CODE>W</CODE>-bit value
consists of <CODE>N</CODE> fields combined as follows:</P>

<UL>
<LI>The first <CODE>N0</CODE> fields consist of the low-order
<CODE>W0</CODE> bits of values returned by the base engine that are
less than <CODE>Y0</CODE>, packed in descending order of significance.
Values that are too large are discarded.</LI>

<LI>The remaining <CODE>N - N0</CODE> fields consist of the low-order
<CODE>W0 + 1</CODE> bits of values returned by the base engine that are
less than <CODE>Y1</CODE>, packed in descending order of significance.
Values that are too large are discarded.</LI>
</UL>

<P>The parameters above (other than <CODE>W</CODE>) are determined
as follows:</P>

<UL>
<LI><CODE>R</CODE> is the full range of values returned by the
base engine (<CODE>stored_eng.max() - stored_eng.min() + 1</CODE>,
assuming no wraparound occurs.)</LI>

<LI><CODE>M</CODE> is <CODE>floor(log2(R))</CODE>.</LI>

<LI><CODE>N</CODE> is initially <CODE>W / M + (W % M != 0)</CODE>.</LI>

<LI><CODE>W0</CODE> is <CODE>W / N</CODE>.</LI>

<LI><CODE>N0</CODE> is <CODE>N - W % N</CODE>.</LI>

<LI><CODE>Y0</CODE> is <CODE>(R &gt;&gt; W0) &lt;&lt; W0</CODE>.</LI>

<LI><CODE>Y1</CODE> is <CODE>(R &gt;&gt; W0 + 1) &lt;&lt; W0 + 1</CODE>.</LI>

<LI>If <CODE>Y0 / N &lt; R - Y0</CODE> then <CODE>N</CODE> is incremented
and the previous four parameters are redetermined.</LI>
</UL>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is
the state of <CODE>stored_eng</CODE>.
The value of the template argument <CODE>W</CODE> must be greater than zero
and not greater than the number of bits representable in <CODE>result_type</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine::base">independent_bits_engine::base</A></CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="independent_bits_engine::base_type">independent_bits_engine::base_type</A></CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="independent_bits_engine::discard">independent_bits_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="independent_bits_engine::independent_bits_engine">independent_bits_engine::independent_bits_engine</A></CODE></H3>

<PRE><B>independent_bits_engine</B>();
explicit <B>independent_bits_engine</B>(const base_type&amp; eng);
explicit <B>independent_bits_engine</B>(result_type x0);
explicit <B>independent_bits_engine</B>(seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>independent_bits_engine</CODE> object with a default-initialized
engine. The second contructor constructs a <CODE>independent_bits_engine</CODE> object with a copy of an
engine object. The third constructor constucts a <CODE>independent_bits_engine</CODE> object with its engine
initialized by <CODE>stored_engine(x0)</CODE>. The fourth constructor constucts a
<CODE>independent_bits_engine</CODE> object with its engine initialized by
<CODE>stored_engine(seq)</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine::max">independent_bits_engine::max</A></CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine::min">independent_bits_engine::min</A></CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine::operator()">independent_bits_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="independent_bits_engine::result_type">independent_bits_engine::result_type</A></CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine::seed">independent_bits_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A>
calls <CODE>stored_eng.seed()</CODE>.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>.
The second seed function calls <CODE>stored_eng.seed(seq)</CODE>.</P>

<H2><CODE><A NAME="knuth_b">knuth_b</A></CODE></H2>

<PRE>typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <B>knuth_b</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>shuffle_order_engine</CODE>
with a specialization of the template <CODE>linear_congruential</CODE>.</P>

<H2><CODE><A NAME="linear_congruential">linear_congruential</A></CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B>linear_congruential</B> {
public:
    typedef UIntType <B><A HREF="#linear_congruential::result_type">result_type</A></B>;
    static constexpr UIntType <B><A HREF="#linear_congruential::multiplier">multiplier</A></B> = A;
    static constexpr UIntType <B><A HREF="#linear_congruential::increment">increment</A></B> = C;
    static constexpr UIntType <B><A HREF="#linear_congruential::modulus">modulus</A></B> = M;

    <B><A HREF="#linear_congruential::linear_congruential">linear_congruential</A></B>();
    explicit <B><A HREF="#linear_congruential::linear_congruential">linear_congruential</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#linear_congruential::linear_congruential">linear_congruential</A></B>(Gen&amp; gen);
    void <B><A HREF="#linear_congruential::seed">seed</A></B>(unsigned long x0 = 1);
    template&lt;class Gen&gt;
        void <B><A HREF="#linear_congruential::seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#linear_congruential::min">min</A></B>() const;
    result_type <B><A HREF="#linear_congruential::max">max</A></B>() const;
    result_type <B><A HREF="#linear_congruential::operator()">operator()</A></B>();

private:
    result_type <B>stored_value</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="linear_congruential::recurrence relation">recurrence relation</A></B>
<CODE>x(i) = (A * x(i-1) + C) mod M</CODE>. The engine's
<A HREF="lib_rand.html#state">state</A> is the last value returned, or the seed
value if no call has been made to <CODE>operator()</CODE>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>A</CODE> and <CODE>C</CODE> must be less than <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::increment">linear_congruential::increment</A></CODE></H3>

<PRE>static constexpr UIntType <B>increment</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::linear_congruential">linear_congruential::linear_congruential</A></CODE></H3>

<PRE><B>linear_congruential</B>();
explicit <B>linear_congruential</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>linear_congruential</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::max">linear_congruential::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::min">linear_congruential::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>C == 0 ? 1 : 0</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::modulus">linear_congruential::modulus</A></CODE></H3>

<PRE>static constexpr UIntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::multiplier">linear_congruential::multiplier</A></CODE></H3>

<PRE>static constexpr UIntType <B>multiplier</B> = A;</PRE>

<P>The static const variable holds the value of template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::operator()">linear_congruential::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates a new <CODE>stored_value</CODE> by applying
the <A HREF="#linear_congruential::recurrence relation">recurrence relation</A> to the old value of
<CODE>stored_value</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::result_type">linear_congruential::result_type</A></CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="linear_congruential::seed">linear_congruential::seed</A></CODE></H3>

<PRE>void <B>seed</B>(unsigned long x0 = 1);
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> sets the stored value
<CODE>stored_value</CODE> to 1 if <CODE>C mod M == 0</CODE> and
<CODE>x0 mod M == 0</CODE>, otherwise it sets the stored value to <CODE>x0 mod M</CODE>.
The second seed function calls <CODE>seed(gen())</CODE>.</P>

<H2><CODE><A NAME="linear_congruential_engine">linear_congruential_engine</A></CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B>linear_congruential_engine</B> { <B>[added with C++0X]</B>
public:
    typedef UIntType <B><A HREF="#linear_congruential_engine::result_type">result_type</A></B>;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine::multiplier">multiplier</A></B> = A;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine::increment">increment</A></B> = C;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine::modulus">modulus</A></B> = M;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine::default_seed">default_seed</A></B> = 1U;

    explicit <B><A HREF="#linear_congruential_engine::linear_congruential_engine">linear_congruential_engine</A></B>(result_type x0 = default_seed);
    explicit <B><A HREF="#linear_congruential_engine::linear_congruential_engine">linear_congruential_engine</A></B>(seed_seq& seq);
    void <B><A HREF="#linear_congruential_engine::seed">seed</A></B>(result_type x0 = default_seed);
    void <B><A HREF="#linear_congruential_engine::seed">seed</A></B>(seed_seq&amp; seq);

    static constexpr result_type <B><A HREF="#linear_congruential_engine::min">min</A></B>();
    static constexpr result_type <B><A HREF="#linear_congruential_engine::max">max</A></B>();
    result_type <B><A HREF="#linear_congruential_engine::operator()">operator()</A></B>();
    void <B><A HREF="#linear_congruential_engine::discard">discard</A></B>(unsigned long long count)();

private:
    result_type <B>stored_value</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="linear_congruential_engine::recurrence relation">recurrence relation</A></B>
<CODE>x(i) = (A * x(i-1) + C) mod M</CODE>. The engine's
<A HREF="lib_rand.html#state">state</A> is the last value returned, or the seed
value if no call has been made to <CODE>operator()</CODE>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>A</CODE> and <CODE>C</CODE> must be less than <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::default_seed">linear_congruential_engine::default_seed</A></CODE></H3>

<PRE>static constexpr UIntType <B>default_seed</B> = 1U;</PRE>

<P>The static const variable holds the default seed value <CODE>1U</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::discard">linear_congruential_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="linear_congruential_engine::increment">linear_congruential_engine::increment</A></CODE></H3>

<PRE>static constexpr UIntType <B>increment</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::linear_congruential_engine">linear_congruential_engine::linear_congruential_engine</A></CODE></H3>

<PRE>explicit <B>linear_congruential_engine</B>(result_type x0 = default_seed);
explicit <B>linear_congruential_engine</B>(seed_seq&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(seq)</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::max">linear_congruential_engine::max</A></CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::min">linear_congruential_engine::min</A></CODE></H3>

<PRE>static constexpr result_type <B>min</B>() const;</PRE>

<P>The static member function returns <CODE>C == 0 ? 1 : 0</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::modulus">linear_congruential_engine::modulus</A></CODE></H3>

<PRE>static constexpr UIntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::multiplier">linear_congruential_engine::multiplier</A></CODE></H3>

<PRE>static constexpr UIntType <B>multiplier</B> = A;</PRE>

<P>The static const variable holds the value of template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::operator()">linear_congruential_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates a new <CODE>stored_value</CODE> by applying
the <A HREF="#linear_congruential_engine::recurrence relation">recurrence relation</A> to the old value of
<CODE>stored_value</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::result_type">linear_congruential_engine::result_type</A></CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine::seed">linear_congruential_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>(result_type x0 = default_seed);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> sets the stored value
<CODE>stored_value</CODE> to 1 if <CODE>C mod M == 0</CODE> and
<CODE>x0 mod M == 0</CODE>, otherwise it sets the stored value to <CODE>x0 mod M</CODE>.
The second seed function calls <CODE>seed(x)</CODE>,
where <CODE>x</CODE> is determined as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>3 + k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[3 + k])</CODE>.</LI>

<LI><CODE>x</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[3]</CODE>, which supplies the lowest-order bits.</LI>
</UL>

<H2><CODE><A NAME="lognormal_distribution">lognormal_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>lognormal_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#lognormal_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#lognormal_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#lognormal_distribution::lognormal_distribution">lognormal_distribution</A></B>(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    explicit <B><A HREF="#lognormal_distribution::lognormal_distribution">lognormal_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#lognormal_distribution::m">m</A></B>() const;
    result_type <B><A HREF="#lognormal_distribution::s">s</A></B>() const;
    param_type <B><A HREF="#lognormal_distribution::param">param</A></B>() const;
    void <B><A HREF="#lognormal_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#lognormal_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#lognormal_distribution::max">max</A></B>() const;
    void <B><A HREF="#lognormal_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#lognormal_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#lognormal_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a log normal distribution.</P>

<H3><CODE><A NAME="lognormal_distribution::lognormal_distribution">lognormal_distribution::lognormal_distribution</A></CODE></H3>

<PRE><B>lognormal_distribution</B>(result_type m0 = result_type(0.0),
    result_type s0 = result_type(1.0));
explicit <B>lognormal_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; s0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_m</CODE>
holds the value <CODE>m0</CODE> and whose stored value <CODE>stored_s</CODE> holds
the value <CODE>s0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::m">lognormal_distribution::m</A></CODE></H3>

<PRE>result_type <B>m</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_m</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::max">lognormal_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::min">lognormal_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::operator()">lognormal_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="lognormal_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::param">lognormal_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::param_type">lognormal_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef lognormal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    result_type m() const;
    result_type s() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="lognormal_distribution::reset">lognormal_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="lognormal_distribution::result_type">lognormal_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution::s">lognormal_distribution::s</A></CODE></H3>

<PRE>result_type <B>s</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_s</CODE>.</P>

<H2><CODE><A NAME="mersenne_twister">mersenne_twister</A></CODE></H2>

<PRE>template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <B>mersenne_twister</B> {
public:
    typedef UIntType <B><A HREF="#mersenne_twister::result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#mersenne_twister::word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#mersenne_twister::state_size">state_size</A></B> = N;
    static constexpr int <B><A HREF="#mersenne_twister::shift_size">shift_size</A></B> = M;
    static constexpr int <B><A HREF="#mersenne_twister::mask_bits">mask_bits</A></B> = R;
    static constexpr UIntType <B><A HREF="#mersenne_twister::parameter_a">parameter_a</A></B> = A;
    static constexpr int <B><A HREF="#mersenne_twister::output_u">output_u</A></B> = U;
    static constexpr int <B><A HREF="#mersenne_twister::output_s">output_s</A></B> = S;
    static constexpr UIntType <B><A HREF="#mersenne_twister::output_b">output_b</A></B> = B;
    static constexpr int <B><A HREF="#mersenne_twister::output_t">output_t</A></B> = T;
    static constexpr UIntType <B><A HREF="#mersenne_twister::output_c">output_c</A></B> = C;
    static constexpr int <B><A HREF="#mersenne_twister::output_l">output_l</A></B> = L;

    <B><A HREF="#mersenne_twister::mersenne_twister">mersenne_twister</A></B>();
    explicit <B><A HREF="#mersenne_twister::mersenne_twister">mersenne_twister</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#mersenne_twister::mersenne_twister">mersenne_twister</A></B>(Gen&amp; gen);
    void <B><A HREF="#mersenne_twister::seed">seed</A></B>();
    void <B><A HREF="#mersenne_twister::seed">seed</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        void <B><A HREF="#mersenne_twister::seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#mersenne_twister::min">min</A></B>() const;
    result_type <B><A HREF="#mersenne_twister::max">max</A></B>() const;
    result_type <B><A HREF="#mersenne_twister::operator()">operator()</A></B>();
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#simple engine">simple engine</A>.
It holds a large integral value with <CODE>W * (N - 1) + R</CODE> bits.
It extracts <CODE>W</CODE> bits at a time from this large value, and when it
has used all the bits it twists the large value by shifting and mixing the bits so that it has
a new set of bits to extract from. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>N</CODE> <CODE>W</CODE>-bit values used if <CODE>operator()</CODE>
has been called at least <CODE>N</CODE> times, otherwise the <CODE>M</CODE>
<CODE>W</CODE>-bit values that have been used and
the last <CODE>N - M</CODE> values of the
<A HREF="lib_rand.html#seed function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>2<SUP>W</SUP> - 1</CODE>. The values of the
other template arguments must satisfy the following requirements:</P>

<UL>
<LI><CODE>1 &lt; M &lt;= N</CODE></LI>
<LI><CODE>0 &lt;= R, U, S, T, L &lt;= W</CODE></LI>
<LI><CODE>0 &lt;= A, B, C &lt;= 2<SUP>W</SUP> - 1</CODE></LI>
<LI><CODE>W * (N - 1) + R</CODE> must be a Mersenne prime</LI>
</UL>

<P>The generator <B><A NAME="mersenne_twister::twists">twists</A></B> the large value that it
holds by executing the following code:</P>

<PRE>    for (int i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] & LMASK) &lt;&lt; (W - 1) | (x[i + 1] & HMASK) &gt;&gt; 1;
        if (temp & 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (int i = 0; i &lt; N; ++i)
            x[i] = y[i];</PRE>

<P>where <CODE>LMASK</CODE> is an unsigned <CODE>W</CODE>-bit value with its
low <CODE>R</CODE> bits set to 1 and the rest of its bits set to 0,
and <CODE>HMASK</CODE> is the complement of <CODE>LMASK</CODE>.</P>

<P>The generator holds a current index <CODE>idx</CODE> initialized to 0.
It <A NAME="mersenne_twister::extracts">extracts bits</A>
by executing the following code:</P>

<PRE>    temp = x[idx++];
    temp = temp ^ (temp &gt;&gt; U);
    temp = temp ^ ((temp &lt;&lt; S) & B);
    temp = temp ^ ((temp &lt;&lt; T) & C);
    temp = temp ^ (temp &gt;&gt; L);</PRE>

<P>When <CODE>idx</CODE> reaches <CODE>N</CODE> the generator
<A HREF="#mersenne_twister::twists">twists</A> the stored value
and sets <CODE>idx</CODE> back to 0.</P>

<H3><CODE><A NAME="mersenne_twister::mask_bits">mersenne_twister::mask_bits</A></CODE></H3>

<PRE>static constexpr int <B>mask_bits</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::max">mersenne_twister::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="mersenne_twister::mersenne_twister">mersenne_twister::mersenne_twister</A></CODE></H3>

<PRE><B>mersenne_twister</B>();
explicit <B>mersenne_twister</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>mersenne_twister</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::min">mersenne_twister::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="mersenne_twister::operator()">mersenne_twister::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function <A HREF="#mersenne_twister::extracts">extracts</A> the
next value in the sequence and returns it.</P>

<H3><CODE><A NAME="mersenne_twister::output_b">mersenne_twister::output_b</A></CODE></H3>

<PRE>static constexpr UIntType <B>output_b</B> = B;</PRE>

<P>The static const variable holds the value of the template argument <CODE>B</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::output_c">mersenne_twister::output_c</A></CODE></H3>

<PRE>static constexpr UIntType <B>output_c</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::output_l">mersenne_twister::output_l</A></CODE></H3>

<PRE>static constexpr int <B>output_l</B> = L;</PRE>

<P>The static const variable holds the value of the template argument <CODE>L</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::output_s">mersenne_twister::output_s</A></CODE></H3>

<PRE>static constexpr int <B>output_s</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::output_t">mersenne_twister::output_t</A></CODE></H3>

<PRE>static constexpr int <B>output_t</B> = T;</PRE>

<P>The static const variable holds the value of the template argument <CODE>T</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::output_u">mersenne_twister::output_u</A></CODE></H3>

<PRE>static constexpr int <B>output_u</B> = U;</PRE>

<P>The static const variable holds the value of the template argument <CODE>U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::parameter_a">mersenne_twister::parameter_a</A></CODE></H3>

<PRE>static constexpr UIntType <B>parameter_a</B> = A;</PRE>

<P>The static const variable holds the value of the template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::result_type">mersenne_twister::result_type</A></CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::seed">mersenne_twister::seed</A></CODE></H3>

<PRE>template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);
void <B>seed</B>();
void <B>seed</B>(unsigned long x0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> 
generates <CODE>N</CODE> values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE> and then <A HREF="#mersenne_twister::twists">twists</A>
the resulting large integer value. Each value is <CODE>gen() % 2<SUP>W</SUP></CODE>.</P>

<P>The second seed function calls <CODE>seed(4357)</CODE>.</P>

<P>The third seed function sets the oldest historical value <CODE>h[0]</CODE> to
<CODE>x0 mod 2<SUP>W</SUP></CODE>, then iteratively sets each successive historical value
<CODE>h[i]</CODE> to <CODE>(i + 1812433253 * (h[i - 1] &gt;&gt; (W - 2))) mod 2<SUP>W</SUP></CODE>,
for <CODE>i</CODE> ranging from <CODE>1</CODE> to <CODE>N - 1</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::shift_size">mersenne_twister::shift_size</A></CODE></H3>

<PRE>static constexpr int <B>shift_size</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::state_size">mersenne_twister::state_size</A></CODE></H3>

<PRE>static constexpr int <B>state_size</B> = N;</PRE>

<P>The static const variable holds the value of the template argument <CODE>N</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister::word_size">mersenne_twister::word_size</A></CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="mersenne_twister_engine">mersenne_twister_engine</A></CODE></H2>

<PRE>template&lt;class UIntType,
    size_t W, size_t N, size_t M, size_t R,
    UIntType A, size_t U,
    UIntType D, size_t S,
    UIntType B, size_t T,
    UIntType C, size_t L
    UIntType F&gt;
    class <B>mersenne_twister_engine</B> { <B>[added with C++0X]</B>
public:
    typedef UIntType <B><A HREF="#mersenne_twister_engine::result_type">result_type</A></B>;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::word_size">word_size</A></B> = W;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::state_size">state_size</A></B> = N;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::shift_size">shift_size</A></B> = M;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::mask_bits">mask_bits</A></B> = R;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine::xor_mask">xor_mask</A></B> = A;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::tempering_u">tempering_u</A></B> = U;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::tempering_d">tempering_d</A></B> = D;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::tempering_s">tempering_s</A></B> = S;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine::tempering_b">tempering_b</A></B> = B;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::tempering_t">tempering_t</A></B> = T;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine::tempering_c">tempering_c</A></B> = C;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine::tempering_l">tempering_l</A></B> = L;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine::initialization_multiplier">initialization_multiplier</A></B> = C;
    static constexpr result_type <B><A HREF="#mersenne_twister_engine::default_seed">default_seed</A></B> = 5489U;

    explicit <B><A HREF="#mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine</A></B>(unsigned long x0 = default_seed);
    explicit <B><A HREF="#mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine</A></B>(seed_seq&amp; seq);
    void <B><A HREF="#mersenne_twister_engine::seed">seed</A></B>(unsigned long x0 = default_seed);
    template&lt;class Gen&gt;
        void <B><A HREF="#mersenne_twister_engine::seed">seed</A></B>(seed_seq&amp; seq);

    result_type <B><A HREF="#mersenne_twister_engine::min">min</A></B>() const;
    result_type <B><A HREF="#mersenne_twister_engine::max">max</A></B>() const;
    result_type <B><A HREF="#mersenne_twister_engine::operator()">operator()</A></B>();
    void <B><A HREF="#mersenne_twister_engine::discard">discard</A></B>(unsigned long long count)();
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#simple engine">simple engine</A>.
It holds a large integral value with <CODE>W * (N - 1) + R</CODE> bits.
It extracts <CODE>W</CODE> bits at a time from this large value, and when it
has used all the bits it twists the large value by shifting and mixing the bits so that it has
a new set of bits to extract from. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>N</CODE> <CODE>W</CODE>-bit values used if <CODE>operator()</CODE>
has been called at least <CODE>N</CODE> times, otherwise the <CODE>M</CODE>
<CODE>W</CODE>-bit values that have been used and
the last <CODE>N - M</CODE> values of the
<A HREF="lib_rand.html#seed function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>2<SUP>W</SUP> - 1</CODE>. The values of the
other template arguments must satisfy the following requirements:</P>

<UL>
<LI><CODE>1 &lt; M &lt;= N</CODE></LI>
<LI><CODE>0 &lt;= R, U, S, T, L &lt;= W</CODE></LI>
<LI><CODE>0 &lt;= A, B, C &lt;= 2<SUP>W</SUP> - 1</CODE></LI>
<LI><CODE>W * (N - 1) + R</CODE> must be a Mersenne prime</LI>
</UL>

<P>The generator <B><A NAME="mersenne_twister_engine::twists">twists</A></B> the large value that it
holds by executing the following code:</P>

<PRE>    for (size_t i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] & LMASK) &lt;&lt; (W - 1) | (x[i + 1] & HMASK) &gt;&gt; 1;
        if (temp & 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (size_t i = 0; i &lt; N; ++i)
            x[i] = y[i];</PRE>

<P>where <CODE>LMASK</CODE> is an unsigned <CODE>W</CODE>-bit value with its
low <CODE>R</CODE> bits set to 1 and the rest of its bits set to 0,
and <CODE>HMASK</CODE> is the complement of <CODE>LMASK</CODE>.</P>

<P>The generator holds a current index <CODE>idx</CODE> initialized to 0.
It <A NAME="mersenne_twister_engine::extracts">extracts bits</A>
by executing the following code:</P>

<PRE>    temp = x[idx++];
    temp = temp ^ ((temp &gt;&gt; U) &amp; D);
    temp = temp ^ ((temp &lt;&lt; S) &amp; B);
    temp = temp ^ ((temp &lt;&lt; T) &amp; C);
    temp = temp ^ (temp &gt;&gt; L);</PRE>

<P>When <CODE>idx</CODE> reaches <CODE>N</CODE> the generator
<A HREF="#mersenne_twister_engine::twists">twists</A> the stored value
and sets <CODE>idx</CODE> back to 0.</P>

<H3><CODE><A NAME="mersenne_twister_engine::default_seed">mersenne_twister_engine::default_seed</A></CODE></H3>

<PRE>static constexpr result_type <B>default_seed</B> = 5489U;</PRE>

<P>The static const variable holds the default seed value <CODE>5489U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::discard">mersenne_twister_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="mersenne_twister_engine::initialization_multiplier">mersenne_twister_engine::initialization_multiplier</A></CODE></H3>

<PRE>static constexpr UIntType <B>initialization_multiplier</B> = F;</PRE>

<P>The static const variable holds the value of the template argument <CODE>F</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::mask_bits">mersenne_twister_engine::mask_bits</A></CODE></H3>

<PRE>static constexpr size_t <B>mask_bits</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::max">mersenne_twister_engine::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine::mersenne_twister_engine</A></CODE></H3>

<PRE>explicit <B>mersenne_twister_engine</B>(unsigned long x0 = default_seed);
<B>explicit mersenne_twister_engine</B>(default_seed&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(seq)</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::min">mersenne_twister_engine::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="mersenne_twister_engine::operator()">mersenne_twister_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function <A HREF="#mersenne_twister_engine::extracts">extracts</A> the
next value in the sequence and returns it.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_b">mersenne_twister_engine::tempering_b</A></CODE></H3>

<PRE>static constexpr UIntType <B>tempering_b</B> = B;</PRE>

<P>The static const variable holds the value of the template argument <CODE>B</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_c">mersenne_twister_engine::tempering_c</A></CODE></H3>

<PRE>static constexpr UIntType <B>tempering_c</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_d">mersenne_twister_engine::tempering_d</A></CODE></H3>

<PRE>static constexpr UIntType <B>tempering_d</B> = D;</PRE>

<P>The static const variable holds the value of the template argument <CODE>D</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_l">mersenne_twister_engine::tempering_l</A></CODE></H3>

<PRE>static constexpr size_t <B>tempering_l</B> = L;</PRE>

<P>The static const variable holds the value of the template argument <CODE>L</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_s">mersenne_twister_engine::tempering_s</A></CODE></H3>

<PRE>static constexpr size_t <B>tempering_s</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_t">mersenne_twister_engine::tempering_t</A></CODE></H3>

<PRE>static constexpr size_t <B>tempering_t</B> = T;</PRE>

<P>The static const variable holds the value of the template argument <CODE>T</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::tempering_u">mersenne_twister_engine::tempering_u</A></CODE></H3>

<PRE>static constexpr size_t <B>tempering_u</B> = U;</PRE>

<P>The static const variable holds the value of the template argument <CODE>U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::result_type">mersenne_twister_engine::result_type</A></CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::seed">mersenne_twister_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>(result_type x0 = default_seed);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first seed function sets the oldest historical value <CODE>h[0]</CODE> to
<CODE>x0 mod 2<SUP>W</SUP></CODE>, then iteratively sets each successive historical value
<CODE>h[i]</CODE> to <CODE>(i + F * (h[i - 1] &gt;&gt; (W - 2))) mod 2<SUP>W</SUP></CODE>,
for <CODE>i</CODE> ranging from <CODE>1</CODE> to <CODE>N - 1</CODE>.</P>

<P>The second seed function sets the <CODE>N</CODE> historical values beginning with
<CODE>h[0]</CODE> as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>N * k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[N * k])</CODE>.</LI>

<LI>Each <CODE>h[i]</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[i * k]</CODE>, which supplies the lowest-order bits.</LI>
</UL>

<H3><CODE><A NAME="mersenne_twister_engine::shift_size">mersenne_twister_engine::shift_size</A></CODE></H3>

<PRE>static constexpr size_t <B>shift_size</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::state_size">mersenne_twister_engine::state_size</A></CODE></H3>

<PRE>static constexpr size_t <B>state_size</B> = N;</PRE>

<P>The static const variable holds the value of the template argument <CODE>N</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::word_size">mersenne_twister_engine::word_size</A></CODE></H3>

<PRE>static constexpr size_t <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine::xor_mask">mersenne_twister_engine::xor_mask</A></CODE></H3>

<PRE>static constexpr UIntType <B>xor_mask</B> = A;</PRE>

<P>The static const variable holds the value of the template argument <CODE>A</CODE>.</P>

<H2><CODE><A NAME="minstd_rand">minstd_rand</A></CODE></H2>
<PRE>typedef linear_congruential&lt; <I>ui-type</I>, 48271, 0, 2147483647&gt; <B>minstd_rand</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>linear_congruential</CODE>.</P>

<H2><CODE><A NAME="minstd_rand0">minstd_rand0</A></CODE></H2>

<PRE>typedef linear_congruential&lt; <I>ui-type</I>, 16807, 0, 2147483647&gt; <B>minstd_rand0</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>linear_congruential</CODE>.</P>

<H2><CODE><A NAME="mt19937">mt19937</A></CODE></H2>
<PRE>typedef mersenne_twister&lt; <I>ui-type</I>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <B>mt19937</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>mersenne_twister</CODE>.</P>

<H2><CODE><A NAME="mt19937_64">mt19937_64</A></CODE></H2>
<PRE>typedef mersenne_twister_engine&lt;<I>ui-type</I>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0xfff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <B>mt19937_64</B> <B>[added with C++0X]</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>mersenne_twister_engine</CODE>.</P>

<H2><CODE><A NAME="negative_binomial_distribution">negative_binomial_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>negative_binomial_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef IntType <B><A HREF="#negative_binomial_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#negative_binomial_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution</A></B>(result_type k0 = 1,
        double p0 = 0.5);
    explicit <B><A HREF="#negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#negative_binomial_distribution::k">k</A></B>() const;
    double <B><A HREF="#negative_binomial_distribution::p">p</A></B>() const;
    param_type <B><A HREF="#negative_binomial_distribution::param">param</A></B>() const;
    void <B><A HREF="#negative_binomial_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#negative_binomial_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#negative_binomial_distribution::max">max</A></B>() const;
    void <B><A HREF="#negative_binomial_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#negative_binomial_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#negative_binomial_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_k</B>;  <I>// exposition only</I>
    double <B>stored_p</B>;       <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed with a binomial
distribution.</P>

<H3><CODE><A NAME="negative_binomial_distribution::k">negative_binomial_distribution::k</A></CODE></H3>

<PRE>result_type <B>k</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_k</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::max">negative_binomial_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::min">negative_binomial_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution::negative_binomial_distribution</A></CODE></H3>

<PRE><B>negative_binomial_distribution</B>(result_type k0 = 1,
    double p0 = 0.5);
explicit <B>negative_binomial_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; k0 &amp;&amp; 0.0 &lt; p0 &amp;&amp; p0 &lt;= 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE> and whose stored value <CODE>stored_k</CODE> holds
the value <CODE>k0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::operator()">negative_binomial_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="negative_binomial_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::p">negative_binomial_distribution::p</A></CODE></H3>

<PRE>double <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::param">negative_binomial_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution::param_type">negative_binomial_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef negative_binomial_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type t0 = 1, double p0 = 0.5);
    result_type k() const;
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="negative_binomial_distribution::reset">negative_binomial_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="negative_binomial_distribution::result_type">negative_binomial_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="normal_distribution">normal_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>normal_distribution</B> {
public:
    typedef T1 <B><A HREF="#normal_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef RealType <B><A HREF="#normal_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#normal_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#normal_distribution::normal_distribution">normal_distribution</A></B>(result_type mean0 = result_type(0.0),
        result_type sigma0 = result_type(1.0));
    explicit <B><A HREF="#normal_distribution::normal_distribution">normal_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#normal_distribution::mean">mean</A></B>() const;
    result_type <B><A HREF="#normal_distribution::sigma">sigma</A></B>() const;
    result_type <B><A HREF="#normal_distribution::stddev">stddev</A></B>() const; <B>[added with C++0X]</B>
    param_type <B><A HREF="#normal_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#normal_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#normal_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#normal_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#normal_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#normal_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#normal_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    result_type <B>stored_mean</B>;     <I>// exposition only</I>
    result_type <B>stored_sigma</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a normal distribution.</P>

<H3><CODE><A NAME="normal_distribution::input_type">normal_distribution::input_type</A></CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::max">normal_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::mean">normal_distribution::mean</A></CODE></H3>

<PRE>result_type <B>mean</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_mean</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::min">normal_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::normal_distribution">normal_distribution::normal_distribution</A></CODE></H3>

<PRE><B>normal_distribution</B>(result_type mean0 = result_type(0.0),
    result_type sigma0 = result_type(1.0));
explicit <B>normal_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; sigma0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_mean</CODE>
holds the value <CODE>mean0</CODE> and whose stored value <CODE>stored_sigma</CODE>
holds the value <CODE>sigma0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::operator()">normal_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="normal_distribution.gif"></PRE>

<H3><CODE><A NAME="normal_distribution::param">normal_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::param_type">normal_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef normal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type mean0 = result_type(0.0),
        RealType sigma0 = result_type(1.0));
    RealType mean() const;
    RealType sigma() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="normal_distribution::reset">normal_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="normal_distribution::result_type">normal_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::sigma">normal_distribution::sigma</A></CODE></H3>

<PRE>result_type <B>sigma</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_sigma</CODE>.</P>

<H3><CODE><A NAME="normal_distribution::stddev">normal_distribution::stddev</A></CODE></H3>

<PRE>result_type <B>stddev</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the stored value <CODE>stored_sigma</CODE>.</P>

<H2><CODE><A NAME="operator_ne">operator!=</A></CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator!=</B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator!=</B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator!=</B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B>operator!=</B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B>operator!=</B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B>operator!=</B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B>operator!=</B>( <B>[added with C++0X]</B>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);</PRE>

<P>The template operators return <CODE>!(left == right)</CODE>.</P>

<H2><CODE><A NAME="operator_eq">operator==</A></CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator==</B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator==</B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator==</B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B>operator==</B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B>operator==</B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B>operator==</B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B>operator==</B>( <B>[added with C++0X]</B>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);</PRE>

<P>The template operators return true if their engine operands have the same
stored parameters and state. (They generate the same sequence.)</P>

<H2><CODE><A NAME="operator_lsh">operator&lt;&lt;</A></CODE></H2>

<PRE>template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++0X]</B>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);</PRE>

<P>The template function inserts into the stream <CODE>ostr</CODE>
sufficient information about <CODE>right</CODE> to restore its stored
parameters with a subsequent extract. The stream must insert integer
values as decimals.</P>

<H2><CODE><A NAME="operator_rsh">operator&gt;&gt;</A></CODE></H2>

<PRE>template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++0X]</B>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);</PRE>

<P>The template function extracts from the stream <CODE>istr</CODE>
sufficient information into <CODE>right</CODE> to restore its stored
parameters from a previous insert. The stream must extract integer
values as decimals.</P>

<H2><CODE><A NAME="piecewise_constant_distribution">piecewise_constant_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>piecewise_constant_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#piecewise_constant_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#piecewise_constant_distribution::param_type">param_type</A></B>;

    <B><A HREF="#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</A></B>();
    template&lt;class InIt1, class InIt2&gt;
        <B><A HREF="#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</A></B>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</A></B>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</A></B>(const param_type&amp; par0);

    std::vector&lt;double&gt; <B><A HREF="#piecewise_constant_distribution::densities">densities</A></B>() const;
    std::vector&lt;RealType&gt; <B><A HREF="#piecewise_constant_distribution::intervals">intervals</A></B>() const;
    param_type <B><A HREF="#piecewise_constant_distribution::param">param</A></B>() const;
    void <B><A HREF="#piecewise_constant_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#piecewise_constant_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#piecewise_constant_distribution::max">max</A></B>() const;
    void <B><A HREF="#piecewise_constant_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_constant_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_constant_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <B>stored_p</B>;    <I>// exposition only</I>
    std::vector&lt;RealType&gt; <B>stored_x</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed according to a varying-width histogram of probabilities.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE><A HREF="#discrete_distribution">discrete_distribution</A></CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE>piecewise_constant_distribution</CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="piecewise_constant_distribution::densities">piecewise_constant_distribution::densities</A></CODE></H3>

<PRE>std::vector&lt;double&gt; <B>densities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>,
with each element <CODE>stored_p[I]</CODE> divided by <CODE>stored_x[I + 1]
- stored_x[I]</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::intervals">piecewise_constant_distribution::intervals</A></CODE></H3>

<PRE>std::vector&lt;RealType&gt; <B>intervals</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_x</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::max">piecewise_constant_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::min">piecewise_constant_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::operator()">piecewise_constant_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> in the range <CODE>[stored_x.front(),
stored_x.back())</CODE> occurring with probability determined by the smallest element
<CODE>I</CODE> for which <CODE>x &lt; stored_x[I + 1}</CODE>, and other values of <CODE>x</CODE>
occurring with probability zero. Values <CODE>x</CODE> are uniformly distributed over the
range <CODE>[stored_x[I], stored_x[I + 1])</CODE> with total probability <CODE>stored_p[I]</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::param">piecewise_constant_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::param_type">piecewise_constant_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef piecewise_constant_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    std::vector&lt;double&gt; densities() const;
    std::vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution::piecewise_constant_distribution</A></CODE></H3>

<PRE><B>piecewise_constant_distribution</B>();
template&lt;class InIt1, class InIt2&gt;
    <B>piecewise_constant_distribution</B>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <B>piecewise_constant_distribution</B>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <B>piecewise_constant_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>piecewise_constant_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements to be stored in
<CODE>stored_p</CODE> are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_x</CODE>
holds the values <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>,
and whose stored value <CODE>stored_p</CODE> holds the value <CODE>1.0</CODE>.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[first1, last1)</CODE>.
If the sequence has fewer than two elements, <CODE>stored_x</CODE> has two
elements <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>, and
<CODE>stored_p</CODE> has one element with value 1.
Otherwise, <CODE>stored_p</CODE> is initialized with <CODE>stored_x.size() - 1</CODE>
elements beginning at <CODE>first2</CODE>, then normalized so that the sum of
all elements is 1.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>.
Its stored value <CODE>stored_p</CODE> is initialized with <CODE>init.size() - 1</CODE> elements,
where element <CODE>I</CODE> stores the value <CODE>func(x)</CODE> for <CODE>x</CODE>
in the middle of subrange <CODE>[stored_x[I], stored_x[I + 1]]</CODE>.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fourth constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
It stores in <CODE>stored_x</CODE> the <CODE>count + 1</CODE> endpoints of these
subranges.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fifth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::result_type">piecewise_constant_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution::reset">piecewise_constant_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H2><CODE><A NAME="piecewise_linear_distribution">piecewise_linear_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>piecewise_linear_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#piecewise_linear_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#piecewise_linear_distribution::param_type">param_type</A></B>;

    <B><A HREF="#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</A></B>();
    template&lt;class InIt1, class InIt2&gt;
        <B><A HREF="#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</A></B>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</A></B>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</A></B>(const param_type&amp; par0);

    std::vector&lt;double&gt; <B><A HREF="#piecewise_linear_distribution::densities">densities</A></B>() const;
    std::vector&lt;RealType&gt; <B><A HREF="#piecewise_linear_distribution::intervals">intervals</A></B>() const;
    param_type <B><A HREF="#piecewise_linear_distribution::param">param</A></B>() const;
    void <B><A HREF="#piecewise_linear_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#piecewise_linear_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#piecewise_linear_distribution::max">max</A></B>() const;
    void <B><A HREF="#piecewise_linear_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_linear_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_linear_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <B>stored_p</B>;    <I>// exposition only</I>
    std::vector&lt;RealType&gt; <B>stored_x</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed according to a varying-width histogram of probabilities,
with probability varying linearly over each interval.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE><A HREF="#discrete_distribution">discrete_distribution</A></CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE>piecewise_linear_distribution</CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="piecewise_linear_distribution::densities">piecewise_linear_distribution::densities</A></CODE></H3>

<PRE>std::vector&lt;double&gt; <B>densities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::intervals">piecewise_linear_distribution::intervals</A></CODE></H3>

<PRE>std::vector&lt;RealType&gt; <B>intervals</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_x</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::max">piecewise_linear_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::min">piecewise_linear_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::operator()">piecewise_linear_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> in the range <CODE>[stored_x.front(),
stored_x.back())</CODE> occurring with probability determined by the smallest element
<CODE>I</CODE> for which <CODE>x &lt; stored_x[I + 1}</CODE>, and other values of <CODE>x</CODE>
occurring with probability zero. Values <CODE>x</CODE> are uniformly distributed over the
range <CODE>[stored_x[I], stored_x[I + 1])</CODE> with probability varying from
<CODE>stored_p[I]</CODE> to <CODE>stored_p[I + 1]</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::param">piecewise_linear_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::param_type">piecewise_linear_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef piecewise_linear_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    std::vector&lt;double&gt; densities() const;
    std::vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution::piecewise_linear_distribution</A></CODE></H3>

<PRE><B>piecewise_linear_distribution</B>();
template&lt;class InIt1, class InIt2&gt;
    <B>piecewise_linear_distribution</B>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <B>piecewise_linear_distribution</B>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <B>piecewise_linear_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>piecewise_linear_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements to be stored in
<CODE>stored_p</CODE> are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_x</CODE>
holds the values <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>,
and whose stored value <CODE>stored_p</CODE> holds the values <CODE>1.0</CODE>
and <CODE>1.0</CODE>.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[first1, last1)</CODE>.
<CODE>stored_p</CODE> is initialized with <CODE>stored_x.size()</CODE>
elements beginning at <CODE>first2</CODE>.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>.
Its stored value <CODE>stored_p</CODE> is initialized with <CODE>init.size()</CODE> elements,
where element <CODE>I</CODE> stores the value <CODE>func(stored_x[I])</CODE>.</P>

<P>The fourth constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
It stores in <CODE>stored_x</CODE> the <CODE>count + 1</CODE> endpoints of these
subranges.</P>

<P>The fifth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<P>In all cases,
if the sequence has fewer than two elements, <CODE>stored_x</CODE> has two
elements <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>, and
<CODE>stored_p</CODE> has two elements with value 1.
Also, <CODE>stored_p</CODE> is normalized so that the sum of
all probability intervals is 1.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::result_type">piecewise_linear_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution::reset">piecewise_linear_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H2><CODE><A NAME="poisson_distribution">poisson_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++0X]</B>
    class <B>poisson_distribution</B> {
public:
    typedef T1 <B><A HREF="#poisson_distribution::input_type">input_type</A></B>; <B>[removed with C++0X]</B>
    typedef IntType <B><A HREF="#poisson_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#poisson_distribution::param_type">param_type</A></B>; <B>[added with C++0X]</B>

    explicit <B><A HREF="#poisson_distribution::poisson_distribution">poisson_distribution</A></B>(RealType mean0 = RealType(1.0));
    explicit <B><A HREF="#poisson_distribution::poisson_distribution">poisson_distribution</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    RealType <B><A HREF="#poisson_distribution::mean">mean</A></B>() const;
    param_type <B><A HREF="#poisson_distribution::param">param</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#poisson_distribution::param">param</A></B>(const param_type&amp; par0); <B>[added with C++0X]</B>

    result_type <B><A HREF="#poisson_distribution::min">min</A></B>() const; <B>[added with C++0X]</B>
    result_type <B><A HREF="#poisson_distribution::max">max</A></B>() const; <B>[added with C++0X]</B>
    void <B><A HREF="#poisson_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#poisson_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#poisson_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++0X]</B>

private:
    RealType <B>stored_mean</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a Poisson distribution.</P>

<H3><CODE><A NAME="poisson_distribution::input_type">poisson_distribution::input_type</A></CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed with C++0X]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::max">poisson_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::mean">poisson_distribution::mean</A></CODE></H3>

<PRE>RealType <B>mean</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_mean</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::min">poisson_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++0X]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::operator()">poisson_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="poisson_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::param">poisson_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++0X]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::param_type">poisson_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++0X]</B>
    typedef poisson_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType mean = RealType(1.0));
    RealType mean() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="poisson_distribution::poisson_distribution">poisson_distribution::poisson_distribution</A></CODE></H3>

<PRE><B>poisson_distribution</B>(RealType mean0 = RealType(1.0));
explicit <B>binomial_distribution</B>(const param_type&amp; par0); <B>[added with C++0X]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; mean0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_mean</CODE>
holds the value <CODE>mean0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution::reset">poisson_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="poisson_distribution::result_type">poisson_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="random_device">random_device</A></CODE></H2>

<PRE>class random_device {
public:
    typedef unsigned int <B><A HREF="#random_device::result_type">result_type</A></B>;

    explicit <B><A HREF="#random_device::random_device">random_device</A></B>(const std::string&amp; token = /* <I>implementation defined</I> */);

    result_type <B><A HREF="#random_device::min">min</A></B>() const;
    result_type <B><A HREF="#random_device::max">max</A></B>() const;
    double <B><A HREF="#random_device::entropy">entropy</A></B>() const;
    result_type <B><A HREF="#random_device::operator()">operator()</A></B>();

private:
    <B>random_device</B>(const random_device&amp;) = delete; <B>[added with C++0X]</B>
    void <B>operator=</B>(const random_device&amp;) = delete; <B>[added with C++0X]</B>
    };</PRE>

<P>The class decribes a source of random numbers, preferably from a
non-deterministic external device. In this implementation
the values produced by default are not non-deterministic.
They are uniformly distributed in the closed range <CODE>[0, 65535]</CODE>.</P>

<H3><CODE><A NAME="random_device::entropy">random_device::entropy</A></CODE></H3>

<PRE>double <B>entropy</B>() const;</PRE>

<P>The member function returns an estimate of the randomness of the
source, as measured in bits. (In the extreme, a non-random source has
an entropy of zero.)</P>

<H3><CODE><A NAME="random_device::max">random_device::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returned by the
source.</P>

<H3><CODE><A NAME="random_device::min">random_device::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returned by the
source.</P>

<H3><CODE><A NAME="random_device::operator()">random_device::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns values uniformly distributed in the closed interval <CODE>[min(), max()]</CODE>.</P>

<H3><CODE><A NAME="random_device::random_device">random_device::random_device</A></CODE></H3>

<PRE><B>random_device</B>(const std::string&amp; str = /* <I>implementation defined</I> */);</PRE>

<P>The constructor initializes the device (as needed) with <CODE>str</CODE>.</P>

<H3><CODE><A NAME="random_device::result_type">random_device::result_type</A></CODE></H3>

<PRE>typedef unsigned int <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>unsigned int</CODE>.</P>

<H2><CODE><A NAME="ranlux_base_01">ranlux_base_01</A></CODE></H2>

<PRE>typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <B>ranlux_base_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux24">ranlux24</A></CODE></H2>

<PRE>typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <B>ranlux24</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block_engine</CODE>
with a specialization of the template <CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux24_base">ranlux24_base</A></CODE></H2>

<PRE>typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 24, 10, 24&gt;
    <B>ranlux24_base</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for a specialization of the template
<CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux3">ranlux3</A></CODE></H2>

<PRE>typedef discard_block&lt;subtract_with_carry&lt; <I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;
    223, 24&gt; <B>ranlux3</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry</CODE>.</P>

<H2><CODE><A NAME="ranlux3_01">ranlux3_01</A></CODE></H2>

<PRE>typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <B>ranlux3_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux4">ranlux4</A></CODE></H2>

<PRE>typedef discard_block&lt;subtract_with_carry&lt; <I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <B>ranlux4</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry</CODE>.</P>

<H2><CODE><A NAME="ranlux4_01">ranlux4_01</A></CODE></H2>

<PRE>typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <B>ranlux4_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux48">ranlux48</A></CODE></H2>

<PRE>typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <B>ranlux48</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block_engine</CODE>
with a specialization of the template <CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux48_base">ranlux48_base</A></CODE></H2>

<PRE>typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 48, 5, 12&gt;
    <B>ranlux48_base</B>; <B>[added with C++0X]</B></PRE>

<P>The type is a synonym for a specialization of the template
<CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux64_base_01">ranlux64_base_01</A></CODE></H2>

<PRE>typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <B>ranlux64_base_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="seed_seq">seed_seq</A></CODE></H2>

<PRE>class <B>seed_seq</B> { <B>[added with C++0X]</B>
public:
    typedef uint_least32_t <B><A HREF="#seed_seq::result_type">result_type</A></B>;

    <B><A HREF="#seed_seq::seed_seq">seed_seq</A></B>();
    template&lt;class Ty&gt;
        <B><A HREF="#seed_seq::seed_seq">seed_seq</A></B>(initializer_list&lt;Ty&gt; init);
    template&lt;class InIt&gt;
        <B><A HREF="#seed_seq::seed_seq">seed_seq</A></B>(InIt first, InIt last);

    template&lt;class RanIt&gt;
        void <B><A HREF="#seed_seq::generate">generate</A></B>(RanIt first, RanIt last,
            size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
                InIt&gt;::value_type&gt;::digits) const;
    size_t <B>size</B>() const;
    template&lt;class OutIt&gt;
        void <B><A HREF="#seed_seq::param">param</A></B>(OutIt dest) const;

private:
    vector&lt;result_type&gt; <B>vec</B>;    <I>// exposition only</I>
    };</PRE>

<P>The class stores a vector of unsigned integer values that can supply a
randomized seed for a random-number engine.</P>

<H3><CODE><A NAME="seed_seq::generate">seed_seq::generate</A></CODE></H3>

<PRE>template&lt;class RanIt&gt;
    void <B>generate</B>(RanIt first, RanIt last) const;</PRE>

<P>The template function initializes the elements of the sequence
<CODE>[first, last)</CODE> (if the sequence is non-empty) as follows:</P>

<PRE>const size_t s = vec.size();
const size_t n = last - first;
const size_t t = 623 &lt;= n ? 11 : 68 &lt;= n ? 7
    : 39 &lt;= n ? 5 : 7 &lt;= n ? 3 : (n - 1) / 2;
const size_t p = (n - t) / 2;
const size_t q = p + t;
const size_t m = n &lt;= s ? s + 1 : n;
size_t k;

for (k = 0; k &lt; n; ++k)
    first[k] = 0x8b8b8b8b;

for (k = 0; k &lt; m; ++k)
    {    // scramble and add any vector contribution
    result_type r1 = 1664525
        * xor27(first[k % n] ^ first[(k + p) % n] ^ first[(k - 1) % n]);
    result_type r2 = r1
        + (k == 0 ? s : k &lt;= s ? k % n + vec[k - 1] : k % n);

    first[(k + p) % n] += r1;
    first[(k + q) % n] += r2;
    first[k] = r2;
    }

for (; k &lt; m + n; ++k)
    {    // rescramble
    result_type r3 = 1566083941
        * xor27(first[k % n] + first[(k + p) % n] + first[(k - 1) % n]);
    result_type r4 = r3 - k % n;

    first[(k + p) % n] ^= r3;
    first[(k + q) % n] ^= r4;
    first[k] = r4;
    }</PRE>

<P>The function <CODE>xor27</CODE> is defined as:</P>

<PRE>result_type xor27(result_type val) const
    {    // shift and merge
    return (val ^ (val &gt;&gt; 27));
    }</PRE>

<H3><CODE><A NAME="seed_seq::param">seed_seq::param</A></CODE></H3>

<PRE>template&lt;class OutIt&gt;
    void <B>param</B>(OutIt dest) const;</PRE>

<P>The template function executes <CODE>copy(vec.begin(), vec.end(), dest)</CODE>.</P>

<H3><CODE><A NAME="seed_seq::result_type">seed_seq::result_type</A></CODE></H3>

<PRE>typedef uint_least32_t <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>uint_least32_t</CODE>.</P>

<H3><CODE><A NAME="seed_seq::seed_seq">seed_seq::seed_seq</A></CODE></H3>

<PRE><B>seed_seq</B>();
template&lt;class Ty&gt;
    <B>seed_seq</B>(initializer_list&lt;Ty&gt; init);
template&lt;class InIt&gt;
    <B>seed_seq</B>(InIt first, InIt last,
        size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
            InIt&gt;::value_type&gt;::digits);</PRE>

<P>The first constructor initializes <CODE>vec</CODE> to an empty vector.
The second constructor initializes <CODE>vec</CODE> with a sequence of
elements in <CODE>[init.begin(), init.end())</CODE>, each reduced modulo 2^32.
The third constructor initializes <CODE>vec</CODE> with a sequence of
elements in <CODE>[first, last)</CODE>, each reduced modulo 2^32.</P>

<H2><CODE><A NAME="shuffle_order_engine">shuffle_order_engine</A></CODE></H2>

<PRE>template&lt;class Engine,
    size_t K&gt;
    class <B>shuffle_order_engine</B> { <B>[added with C++0X]</B>
public:
    typedef Engine <B><A HREF="#shuffle_order_engine::base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#shuffle_order_engine::result_type">result_type</A></B>;

    static constexpr size_t <B><A HREF="#shuffle_order_engine::table_size">table_size</A></B> = K;

    <B><A HREF="#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</A></B>();
    explicit <B><A HREF="#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</A></B>(result_type x0);
    explicit <B><A HREF="#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</A></B>(seed_seq&amp; seq);
    void <B><A HREF="#shuffle_order_engine::seed">seed</A></B>();
    void <B><A HREF="#shuffle_order_engine::seed">seed</A></B>(result_type x0);
    void <B><A HREF="#shuffle_order_engine::seed">seed</A></B>(seed_seq& seq);

    const base_type&amp; <B><A HREF="#shuffle_order_engine::base">base</A></B>() const;
    static constexpr result_type <B><A HREF="#shuffle_order_engine::min">min</A></B>();
    static constexpr result_type <B><A HREF="#shuffle_order_engine::max">max</A></B>();
    result_type <B><A HREF="#shuffle_order_engine::operator()">operator()</A></B>();
    void <B><A HREF="#shuffle_order_engine::discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;         <I>// exposition only</I>
    result_type <B>stored_arr[K]</B>; <I>// exposition only</I>
    result_type <B>stored_y</B>;      <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#compound engine">compound engine</A>
that produces values by reordering the values
returned by its base engine. Each constructor fills the array <CODE>stored_arr</CODE>
with <CODE>K</CODE> values returned by the base engine. It then stores in
<CODE>stored_y</CODE> an additional value returned by the base engine.
Each element of the generated sequence is then obtained from <CODE>stored_y</CODE>,
after which:</P>

<UL>
<LI>The array index <CODE>J</CODE> is computed as <CODE>K * (stored_y - min())
/ (max() - min() + 1)</CODE>.</LI>

<LI><CODE>stored_y</CODE> is replaced by <CODE>stored_arr[J]</CODE>.</LI>

<LI><CODE>stored_arr[j]</CODE> is replaced by <CODE>stored_eng()</CODE>.</LI>
</UL>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>,
followed by the <CODE>K</CODE> elements of <CODE>stored_arr</CODE>, followed by
<CODE>stored_y</CODE>.</P>

<P>The value of the template argument <CODE>K</CODE> must be greater than zero.</P>

<H3><CODE><A NAME="shuffle_order_engine::base">shuffle_order_engine::base</A></CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="shuffle_order_engine::base_type">shuffle_order_engine::base_type</A></CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="shuffle_order_engine::discard">shuffle_order_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="shuffle_order_engine::shuffle_order_engine">shuffle_order_engine::shuffle_order_engine</A></CODE></H3>

<PRE><B>shuffle_order_engine</B>();
explicit <B>shuffle_order_engine</B>(const base_type&amp; eng);
explicit <B>shuffle_order_engine</B>(result_type x0);
explicit <B>shuffle_order_engine</B>(seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>shuffle_order_engine</CODE> object with a default-initialized
engine. The second contructor constructs a <CODE>shuffle_order_engine</CODE> object with a copy of an
engine object. The third constructor constucts a <CODE>shuffle_order_engine</CODE> object with its engine
initialized by <CODE>stored_engine(x0)</CODE>. The fourth constructor constucts a
<CODE>shuffle_order_engine</CODE> object with its engine initialized by
<CODE>stored_engine(seq)</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine::max">shuffle_order_engine::max</A></CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine::min">shuffle_order_engine::min</A></CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine::operator()">shuffle_order_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="shuffle_order_engine::result_type">shuffle_order_engine::result_type</A></CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine::seed">shuffle_order_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A>
calls <CODE>stored_eng.seed()</CODE>.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>.
The second seed function calls <CODE>stored_eng.seed(seq)</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine::table_size">shuffle_order_engine::table_size</A></CODE></H3>

<PRE>static constexpr size_t <B>table_size</B> = K;</PRE>

<P>The static const variable has the same value as the template parmaeter <CODE>K</CODE>.</P>

<H2><CODE><A NAME="student_t_distribution">student_t_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>student_t_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#student_t_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#student_t_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#student_t_distribution::student_t_distribution">student_t_distribution</A></B>(RealType n0 = 1);
    explicit <B><A HREF="#student_t_distribution::student_t_distribution">student_t_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#student_t_distribution::n">n</A></B>() const;
    param_type <B><A HREF="#student_t_distribution::param">param</A></B>() const;
    void <B><A HREF="#student_t_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#student_t_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#student_t_distribution::max">max</A></B>() const;
    void <B><A HREF="#student_t_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#student_t_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#student_t_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Student T distribution.</P>

<H3><CODE><A NAME="student_t_distribution::max">student_t_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::min">student_t_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::n">student_t_distribution::n</A></CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::operator()">student_t_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="student_t_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::param">student_t_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::param_type">student_t_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef student_t_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="student_t_distribution::reset">student_t_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="student_t_distribution::result_type">student_t_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution::student_t_distribution">student_t_distribution::student_t_distribution</A></CODE></H3>

<PRE><B>student_t_distribution</B>(RealType n0 = 1);
explicit <B>student_t_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry">subtract_with_carry</A></CODE></H2>

<PRE>template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <B>subtract_with_carry</B> {
public:
    typedef IntType <B><A HREF="#subtract_with_carry::result_type">result_type</A></B>;
    static constexpr IntType <B><A HREF="#subtract_with_carry::modulus">modulus</A></B> = M;
    static constexpr int <B><A HREF="#subtract_with_carry::short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry::long_lag">long_lag</A></B> = R;

    <B><A HREF="#subtract_with_carry::subtract_with_carry">subtract_with_carry</A></B>();
    explicit <B><A HREF="#subtract_with_carry::subtract_with_carry">subtract_with_carry</A></B>(IntType x0);
    template&lt;class Gen&gt;
        <B><A HREF="#subtract_with_carry::subtract_with_carry">subtract_with_carry</A></B>(Gen&amp; gen);
    void <B><A HREF="#subtract_with_carry::seed">seed</A></B>(IntType x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <B><A HREF="#subtract_with_carry::seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#subtract_with_carry::min">min</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry::max">max</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry::operator()">operator()</A></B>();
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#simple engine">simple engine</A>
that produces values of a user-specified integral type using the
<B><A NAME="subtract_with_carry::recurrence relation">recurrence relation</A></B>
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>1</CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>.</P>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is a carry indicator plus
<CODE>R</CODE> values. These values consist of the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>N</CODE> values that have been returned and
the last <CODE>R - N</CODE> values of the
<A HREF="lib_rand.html#seed function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#IntType">IntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::long_lag">subtract_with_carry::long_lag</A></CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::max">subtract_with_carry::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::min">subtract_with_carry::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry::modulus">subtract_with_carry::modulus</A></CODE></H3>

<PRE>static constexpr IntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::operator()">subtract_with_carry::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry::recurrence relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry::result_type">subtract_with_carry::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::seed">subtract_with_carry::seed</A></CODE></H3>

<PRE>void <B>seed</B>(unsigned long x0 = 19780503UL);
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> 
generates <CODE>long_lag</CODE> historical values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE>. Each historical value is <CODE>gen() % modulus</CODE>.</P>

<P>The second seed function effectively executes the following code:</P>

<PRE>    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);</PRE>

<H3><CODE><A NAME="subtract_with_carry::short_lag">subtract_with_carry::short_lag</A></CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry::subtract_with_carry">subtract_with_carry::subtract_with_carry</A></CODE></H3>

<PRE><B>subtract_with_carry</B>();
explicit <B>subtract_with_carry</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>subtract_with_carry</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry_engine">subtract_with_carry_engine</A></CODE></H2>

<PRE>template&lt;class UIntType,
    int W, int S, int R&gt;
    class <B>subtract_with_carry_engine</B> { <B>[added with C++0X]</B>
public:
    typedef UIntType <B><A HREF="#subtract_with_carry_engine::result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#subtract_with_carry_engine::word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#subtract_with_carry_engine::short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry_engine::long_lag">long_lag</A></B> = R;
    static constexpr UIntType <B><A HREF="#subtract_with_carry_engine::default_seed">default_seed</A></B> = 19780503U;

    explicit <B><A HREF="#subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine</A></B>(UIntType x0 = default_seed);
    explicit <B><A HREF="#subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine</A></B>(seed_seq&amp; seq);
    void <B><A HREF="#subtract_with_carry_engine::seed">seed</A></B>(UIntType x0 = default_seed);
    void <B><A HREF="#subtract_with_carry_engine::seed">seed</A></B>(seed_seq&amp; seq);

    static constexpr result_type <B><A HREF="#subtract_with_carry_engine::min">min</A></B>();
    static constexpr result_type <B><A HREF="#subtract_with_carry_engine::max">max</A></B>();
    result_type <B><A HREF="#subtract_with_carry_engine::operator()">operator()</A></B>();
    void <B><A HREF="#subtract_with_carry_engine::discard">discard</A></B>(unsigned long long count)();
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#simple engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="subtract_with_carry_engine::recurrence relation">recurrence relation</A></B>
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>1</CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>, and <CODE>M</CODE> has the value <CODE>2<SUP>W</SUP></CODE>.
(Note that the template parameter <CODE>W</CODE> here replaces the template
parameter <CODE>M</CODE> for
<CODE><A HREF="#subtract_with_carry">subtract_with_carry</A></CODE>.)
The engine's <A HREF="lib_rand.html#state">state</A> is a carry indicator plus
<CODE>R</CODE> values. These values consist of the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>N</CODE> values that have been returned and
the last <CODE>R - N</CODE> values of the
<A HREF="lib_rand.html#seed function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::default_seed">subtract_with_carry_engine::default_seed</A></CODE></H3>

<PRE>static constexpr UIntType <B>default_seed</B> = 19780503U;</PRE>

<P>The static const variable holds the default seed value <CODE>19780503U</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::discard">subtract_with_carry_engine::discard</A></CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::long_lag">subtract_with_carry_engine::long_lag</A></CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::max">subtract_with_carry_engine::max</A></CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::min">subtract_with_carry_engine::min</A></CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::operator()">subtract_with_carry_engine::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry_engine::recurrence relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::result_type">subtract_with_carry_engine::result_type</A></CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::seed">subtract_with_carry_engine::seed</A></CODE></H3>

<PRE>void <B>seed</B>(UIntType x0 = default_seed);
void <B>seed</B>(seed_seq&amp; seq);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> 
effectively constructs the engine <CODE>gen</CODE>:</P>

<PRE>linear_congruential_engine&lt;UIntType, 40014, 0, 2147483563&gt;
    gen(x0 == 0 ? default_seed: x0);</PRE>

<P>It then sets the <CODE>R</CODE> historical values beginning with <CODE>h[0]</CODE> to
the values produced by calling <CODE>gen()</CODE>.</P>

<P>The second seed function sets these historical values as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>R * k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[R * k])</CODE>.</LI>

<LI>Each <CODE>h[i]</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[i * k]</CODE>, which supplies the lowest-order bits.</LI>

<LI>Each <CODE>h[i]</CODE> is reduced modulo <CODE>M</CODE>.</LI>
</UL>

<P>In either case, the stored carry is <CODE>h[R - 1] == 0</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::short_lag">subtract_with_carry_engine::short_lag</A></CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine::subtract_with_carry_engine</A></CODE></H3>

<PRE>explicit <B>subtract_with_carry_engine</B>(UIntType x0 = default_seed);
<B>subtract_with_carry_engine</B>(seed_seq&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The secibd constructor constructs an object and initializes it by
calling <CODE>seed(seq)</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine::word_size">subtract_with_carry_engine::word_size</A></CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry_01">subtract_with_carry_01</A></CODE></H2>

<PRE>template&lt;class RealType,
    int W, int S, int R&gt;
    class <B>subtract_with_carry_01</B> {
public:
    typedef RealType <B><A HREF="#subtract_with_carry_01::result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#subtract_with_carry_01::word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#subtract_with_carry_01::short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry_01::long_lag">long_lag</A></B> = R;

    <B><A HREF="#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</A></B>();
    explicit <B><A HREF="#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</A></B>(Gen&amp; gen);
    void <B><A HREF="#subtract_with_carry_01::seed">seed</A></B>(unsigned long x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <B><A HREF="#subtract_with_carry_01::seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#subtract_with_carry_01::min">min</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry_01::max">max</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry_01::operator()">operator()</A></B>();
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#simple engine">simple engine</A>
that produces values of a user-specified floating-point type using the
<B><A NAME="subtract_with_carry_01::recurrence relation">recurrence relation</A></B>
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod 1</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>2<SUP>-W</SUP></CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>M</CODE> values that have been returned and
the last <CODE>R - M</CODE> values of the
<A HREF="lib_rand.html#seed function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#RealType">RealType</A> must be
large enough to hold values with <CODE>W</CODE> fraction bits. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01::long_lag">subtract_with_carry_01::long_lag</A></CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01::max">subtract_with_carry_01::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="subtract_with_carry_01::min">subtract_with_carry_01::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry_01::operator()">subtract_with_carry_01::operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry::recurrence relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry_01::result_type">subtract_with_carry01::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01::seed">subtract_with_carry_01::seed</A></CODE></H3>

<PRE>template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);
void <B>seed</B>(unsigned long x0 = 19780503UL);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A> 
generates <CODE>long_lag</CODE> historical values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE>. Each historical value is generated
by concatenating the low 32 bits from each of <CODE>long_lag * (word_size + 31) / 32</CODE>
values from the initialization sequence; the resulting value is then divided by
<CODE>2.0<SUP>word_size</SUP></CODE> and the integral part discarded. Thus, each historical value
is a floating-point value greater than or equal to 0.0 and less than 1.0, with
<CODE>word_size</CODE> significant bits.</P>

<P>The second seed function effectively executes the following code:</P>

<PRE>    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);</PRE>

<H3><CODE><A NAME="subtract_with_carry_01::short_lag">subtract_with_carry_01::short_lag</A></CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01::subtract_with_carry_01</A></CODE></H3>

<PRE><B>subtract_with_carry_01</B>();
explicit <B>subtract_with_carry_01</B>(IntType x0);
template&lt;class In&gt;
    <B>subtract_with_carry_01</B>(InIt&amp; first, InIt last);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(first, last)</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01::word_size">subtract_with_carry_01::word_size</A></CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="uniform_int">uniform_int</A></CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>uniform_int</B> {
public:
    typedef IntType <B><A HREF="#uniform_int::input_type">input_type</A></B>;
    typedef IntType <B><A HREF="#uniform_int::result_type">result_type</A></B>;

    explicit <B><A HREF="#uniform_int::uniform_int">uniform_int</A></B>(result_type min0 = 0,
        result_type max0 = 9);

    result_type <B><A HREF="#uniform_int::min">min</A></B>() const;
    result_type <B><A HREF="#uniform_int::max">max</A></B>() const;
    void <B><A HREF="#uniform_int::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int::operator()">operator()</A></B>(Engine&amp; eng, result_type n);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_int::input_type">uniform_int::input_type</A></CODE></H3>

<PRE>typedef IntType <B>input_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int::max">uniform_int::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int::min">uniform_int::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int::operator()">uniform_int::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng, result_type n);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the closed range <CODE>[min(), max()]</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<P>The second member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the half-open range <CODE>[0, n)</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<H3><CODE><A NAME="uniform_int::reset">uniform_int::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_int::result_type">uniform_int::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int::uniform_int">uniform_int::uniform_int</A></CODE></H3>

<PRE>explicit <B>uniform_int</B>(result_type min0 = 0, result_type max0 = 9);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt; max0</CODE></P>

<P>The constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<H2><CODE><A NAME="uniform_int_distribution">uniform_int_distribution</A></CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>uniform_int_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef IntType <B><A HREF="#uniform_int_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#uniform_int_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#uniform_int_distribution::uniform_int_distribution">uniform_int_distribution</A></B>(result_type min0 = 0,
        result_type max0 = std::numeric_limits&lt;IntType&gt;::max());
    explicit <B><A HREF="#uniform_int_distribution::uniform_int_distribution">uniform_int_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_int_distribution::a">a</A></B>() const;
    result_type <B><A HREF="#uniform_int_distribution::b">b</A></B>() const;
    param_type <B><A HREF="#uniform_int_distribution::param">param</A></B>() const;
    void <B><A HREF="#uniform_int_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_int_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#uniform_int_distribution::max">max</A></B>() const;
    void <B><A HREF="#uniform_int_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_int_distribution::a">uniform_int_distribution::a</A></CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::b">uniform_int_distribution::b</A></CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::max">uniform_int_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::min">uniform_int_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::operator()">uniform_int_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the closed range <CODE>[min(), max()]</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::param">uniform_int_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::param_type">uniform_int_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef uniform_int_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type a0 = 0,
        result_type b0 = std::numeric_limits&lt;IntType&gt;::max());
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="uniform_int_distribution::reset">uniform_int_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_int_distribution::result_type">uniform_int_distribution::result_type</A></CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution::uniform_int_distribution">uniform_int_distribution::uniform_int_distribution</A></CODE></H3>

<PRE>explicit <B>uniform_int_distribution</B>(result_type min0 = 0,
    result_type max0 = std::numeric_limits&lt;IntType&gt;::max());
explicit <B>uniform_int_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt; max0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="uniform_real">uniform_real</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>uniform_real</B> {
public:
    typedef RealType <B><A HREF="#uniform_real::input_type">input_type</A></B>;
    typedef RealType <B><A HREF="#uniform_real::result_type">result_type</A></B>;

    explicit <B><A HREF="#uniform_real::uniform_real">uniform_real</A></B>(result_type min0 = result_type(0),
        result_type max0 = result_type(1));

    result_type <B><A HREF="#uniform_real::min">min</A></B>() const;
    result_type <B><A HREF="#uniform_real::max">max</A></B>() const;
    void <B><A HREF="#uniform_real::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real::operator()">operator()</A></B>(Engine&amp; eng);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_real::input_type">uniform_real::input_type</A></CODE></H3>

<PRE>typedef RealType <B>input_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real::max">uniform_real::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real::min">uniform_real::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real::operator()">uniform_real::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);</PRE>

<P>The member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed floating-point values and returns floating-point values with
each value <CODE>x</CODE> in the half-open range <CODE>[min(), max())</CODE> occurring
with equal probability, and values outside that range occurring with probability 0.</P>

<H3><CODE><A NAME="uniform_real::reset">uniform_real::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_real::result_type">uniform_real::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real::uniform_real">uniform_real::uniform_real</A></CODE></H3>

<PRE>explicit <B>uniform_real</B>(result_type min0 = result_type(0),
    result_type max0 = result_type(1));</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt; max0</CODE></P>

<P>The constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<H2><CODE><A NAME="uniform_real_distribution">uniform_real_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>uniform_real_distribution</B> {
public:
    typedef RealType <B><A HREF="#uniform_real_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#uniform_real_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#uniform_real_distribution::uniform_real_distribution">uniform_real_distribution</A></B>(result_type min0 = result_type(0.0),
        result_type max0 = result_type(1.0));
    explicit <B><A HREF="#uniform_real_distribution::uniform_real_distribution">uniform_real_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_real_distribution::a">a</A></B>() const;
    result_type <B><A HREF="#uniform_real_distribution::b">b</A></B>() const;
    param_type <B><A HREF="#uniform_real_distribution::param">param</A></B>() const;
    void <B><A HREF="#uniform_real_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_real_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#uniform_real_distribution::max">max</A></B>() const;
    void <B><A HREF="#uniform_real_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_real_distribution::a">uniform_real_distribution::a</A></CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::b">uniform_real_distribution::b</A></CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::max">uniform_real_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::min">uniform_real_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::operator()">uniform_real_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed floating-point values and returns floating-point values with
each value <CODE>x</CODE> in the half-open range <CODE>[min(), max())</CODE> occurring
with equal probability, and values outside that range occurring with probability 0.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::param">uniform_real_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::param_type">uniform_real_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef uniform_real_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="uniform_real_distribution::reset">uniform_real_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_real_distribution::result_type">uniform_real_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution::uniform_real_distribution">uniform_real_distribution::uniform_real_distribution</A></CODE></H3>

<PRE>explicit <B>uniform_real_distribution</B>(result_type min0 = result_type(0.0),
    result_type max0 = result_type(1.0));
explicit <B>uniform_real_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt; max0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="variate_generator">variate_generator</A></CODE></H2>

<PRE>template&lt;class Engine, class Dist&gt;
    class <B>variate_generator</B> {
public:
    typedef Engine <B><A HREF="#variate_generator::engine_type">engine_type</A></B>;
    typedef <I>engine-return-type</I> <B><A HREF="#variate_generator::engine_value_type">engine_value_type</A></B>;
    typedef Dist <B><A HREF="#variate_generator::distribution_type">distribution_type</A></B>;
    typedef typename Dist::result_type <B><A HREF="#variate_generator::result_type">result_type</A></B>;

    <B><A HREF="#variate_generator::variate_generator">variate_generator</A></B>(engine_type eng0, distribution_type dist0);

    result_type <B><A HREF="#variate_generator::operator()">operator()</A></B>();
    template&lt;class T&gt;
        result_type <B><A HREF="#variate_generator::operator()">operator()</A></B>(T value);
    engine_value_type&amp; <B><A HREF="#variate_generator::engine">engine</A></B>();
    const engine_value_type&amp; <B><A HREF="#variate_generator::engine">engine</A></B>() const;
    distribution_type&amp; <B><A HREF="#variate_generator::distribution">distribution</A></B>();
    const distribution_type&amp; <B><A HREF="#variate_generator::distribution">distribution</A></B>() const;
    result_type <B><A HREF="#variate_generator::min">min</A></B>() const;
    result_type <B><A HREF="#variate_generator::max">max</A></B>() const;

private:
    Engine eng;             <I>// exposition only</I>
    Dist dist;              <I>// exposition only</I>
    };</PRE>

<P>The template class describes an object that holds an
<A HREF="lib_rand.html#engine">engine</A> and a
<A HREF="lib_rand.html#distribution">distribution</A> and produces values by
passing the <A HREF="#wrapped engine">wrapped engine</A> object to the
<CODE>distribution</CODE> object's <CODE>operator()</CODE>.</P>

<P>The template argument <CODE>Engine</CODE> can be a type <CODE>Eng</CODE>,
<CODE>Eng*</CODE>, or <CODE>Eng&amp;</CODE>, where <CODE>Eng</CODE> is an
<A HREF="lib_rand.html#engine">engine</A>. The type <CODE>Eng</CODE> is
the <B><A NAME="underlying engine type">underlying engine type</A></B>.
The corresponding object of type <CODE>Eng</CODE> is the
the <B><A NAME="underlying engine object">underlying engine object</A></B>.</P>

<P>The template uses a <B><A NAME="wrapped engine">wrapped engine</A></B> to match
the type of the values produced by the <CODE>engine</CODE> object to the type of
values required by the <CODE>distribution</CODE> object. The wrapped engine's
<CODE>operator()</CODE> returns values of type <CODE>Dist::input_type</CODE>,
generated as follows:</P>

<UL>
<LI>if <CODE>Engine::result_type</CODE> and <CODE>Dist::input_type</CODE> are both
integral types it returns <CODE>eng()</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> and <CODE>Dist::input_type</CODE> are both
floating-point types it returns <CODE>(eng() - eng.min()) / (eng.max() - eng.min())</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> is an integral type and <CODE>Dist::input_type</CODE> 
is a floating-point type it returns <CODE>(eng() - eng.min()) / (eng.max() - eng.min() + 1)</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> is a floating-point type and <CODE>Dist::input_type</CODE> 
is an integral type it returns
<CODE>((eng() - eng.min()) / (eng.max() - eng.min()) * std::numeric_limits&lt;Dist::input_type&gt;::max()</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>
</UL>

<H3><CODE><A NAME="variate_generator::distribution">variate_generator::distribution</A></CODE></H3>

<PRE>distribution_type& <B>distribution</B>();
const distribution_type& <B>distribution</B>() const;</PRE>

<P>The member functions return a reference to the stored distribution object <CODE>dist</CODE>.</P>

<H3><CODE><A NAME="variate_generator::distribution_type">variate_generator::distribution_type</A></CODE></H3>

<PRE>typedef Dist <B>distribution_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Dist</CODE>.

<H3><CODE><A NAME="variate_generator::engine">variate_generator::engine</A></CODE></H3>

<PRE>engine_value_type <B>engine()</B>;
const engine_value_type& <B>engine</B>() const;</PRE>

<P>The member functions return a reference to the <A HREF="#underlying engine object">underlying engine object</A>.</P>

<H3><CODE><A NAME="variate_generator::engine_type">variate_generator::engine_type</A></CODE></H3>

<PRE>typedef Engine <B>engine_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine</CODE>.</P>

<H3><CODE><A NAME="variate_generator::engine_value_type">variate_generator::engine_value_type</A></CODE></H3>

<PRE>typedef <I>engine-value-type</I> <B>engine_value_type</B>;</PRE>

<P>The type is a synonym for the type of values returned by the
<A HREF="#underlying engine type">underlying engine type</A>.</P>

<H3><CODE><A NAME="variate_generator::max">variate_generator::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>dist.max()</CODE>.</P>

<H3><CODE><A NAME="variate_generator::min">variate_generator::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>dist.min()</CODE>.</P>

<H3><CODE><A NAME="variate_generator::operator()">variate_generator::operator()</A></CODE></H3>

<PRE>result_type <B>operator</B>()();
template&lt;class T&gt;
    result_type <B>operator</B>()(T value);</PRE>

<P>The first member operator returns <CODE>dist(wr_eng)</CODE>, where <CODE>wr_eng</CODE>
is the object's <A HREF="#wrapped engine">wrapped engine</A>.</P>

<P>The second member function returns <CODE>dist(wr_eng, value)</CODE>, where <CODE>wr_eng</CODE>
is the object's <A HREF="#wrapped engine">wrapped engine</A>.</P>

<H3><CODE><A NAME="variate_generator::result_type">variate_generator::result_type</A></CODE></H3>

<PRE>typedef typename Dist::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>Dist::result_type</CODE>.</P>

<H3><CODE><A NAME="variate_generator::variate_generator">variate_generator::variate_generator</A></CODE></H3>

<PRE><B>variate_generator</B>(engine_type eng0, distribution_type dist0);</PRE>

<P>The constructor constructs an object whose stored value <CODE>eng</CODE>
holds <CODE>eng0</CODE> and whose stored value <CODE>dist</CODE> holds <CODE>dist0</CODE>.</P>

<H2><CODE><A NAME="weibull_distribution">weibull_distribution</A></CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>weibull_distribution</B> { <B>[added with C++0X]</B>
public:
    typedef RealType <B><A HREF="#weibull_distribution::result_type">result_type</A></B>;
    struct <B><A HREF="#weibull_distribution::param_type">param_type</A></B>;

    explicit <B><A HREF="#weibull_distribution::weibull_distribution">weibull_distribution</A></B>(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#weibull_distribution::weibull_distribution">weibull_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#weibull_distribution::a">a</A></B>() const;
    result_type <B><A HREF="#weibull_distribution::b">b</A></B>() const;
    param_type <B><A HREF="#weibull_distribution::param">param</A></B>() const;
    void <B><A HREF="#weibull_distribution::param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#weibull_distribution::min">min</A></B>() const;
    result_type <B><A HREF="#weibull_distribution::max">max</A></B>() const;
    void <B><A HREF="#weibull_distribution::reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#weibull_distribution::operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#weibull_distribution::operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Weibull distribution.</P>

<H3><CODE><A NAME="weibull_distribution::a">weibull_distribution::a</A></CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::b">weibull_distribution::b</A></CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::max">weibull_distribution::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::min">weibull_distribution::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::operator()">weibull_distribution::operator()</A></CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<PRE>    <IMG SRC="weibull_distribution.gif"></PRE>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::param">weibull_distribution::param</A></CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::param_type">weibull_distribution::param_type</A></CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef weibull_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="weibull_distribution::reset">weibull_distribution::reset</A></CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="weibull_distribution::result_type">weibull_distribution::result_type</A></CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution::weibull_distribution">weibull_distribution::weibull_distribution</A></CODE></H3>

<PRE><B>weibull_distribution</B>(result_type a0 = result_type(1.0),
    result_type b0 = result_type(1.0));
explicit <B>weibull_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; a0 &amp;&amp; 0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="xor_combine">xor_combine</A></CODE></H2>

<PRE>template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <B>xor_combine</B> { <B>[removed with C++0X]</B>
public:
    typedef Engine1 <B><A HREF="#xor_combine::base1_type">base1_type</A></B>;
    typedef Engine2 <B><A HREF="#xor_combine::base2_type">base2_type</A></B>;
    typedef T1 <B><A HREF="#xor_combine::result_type">result_type</A></B>;

    static constexpr int <B><A HREF="#xor_combine::shift1">shift1</A></B> = S1;
    static constexpr int <B><A HREF="#xor_combine::shift2">shift2</A></B> = S2;

    <B><A HREF="#xor_combine::xor_combine">xor_combine</A></B>();
    <B><A HREF="#xor_combine::xor_combine">xor_combine</A></B>(result_type x0);
    <B><A HREF="#xor_combine::xor_combine">xor_combine</A></B>(const base1_type&amp; eng1, const base2_type&amp; eng2);
    template&lt;class Gen&gt;
        <B><A HREF="#xor_combine::xor_combine">xor_combine</A></B>(Gen&amp; gen);
    void <B><A HREF="#xor_combine::seed">seed</A></B>();
    template&lt;class Gen&gt;
        void <B><A HREF="#xor_combine::seed">seed</A></B>(Gen&amp; gen);

    const base1_type&amp; <B><A HREF="#xor_combine::base1">base1</A></B>() const;
    const base2_type&amp; <B><A HREF="#xor_combine::base2">base2</A></B>() const;
    result_type <B><A HREF="#xor_combine::min">min</A></B>() const;
    result_type <B><A HREF="#xor_combine::max">max</A></B>() const;
    result_type <B><A HREF="#xor_combine::operator()">operator()</A></B>();

private:
    base1_type stored_eng1;     <I>// exposition only</I>
    base2_type stored_eng2;     <I>// exposition only</I>
    };</PRE>

<P>The template class decribes a <A HREF="lib_rand.html#compound engine">compound engine</A>
that produces values by combining values produced by two engines. The engine's
<A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng1</CODE>
followed by the state of <CODE>stored_eng2</CODE>.</P>

<H3><CODE><A NAME="xor_combine::base1">xor_combine::base1</A></CODE></H3>

<PRE>const base1_type&amp; <B>base1</B>() const;</PRE>

<P>The member function returns a reference to the stored value <CODE>stored_eng1</CODE>.</P>

<H3><CODE><A NAME="xor_combine::base1_type">xor_combine::base1_type</A></CODE></H3>

<PRE>typedef Engine1 <B>base1_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine1</CODE>.</P>

<H3><CODE><A NAME="xor_combine::base2">xor_combine::base2</A></CODE></H3>

<PRE>const base2_type&amp; <B>base2</B>() const;</PRE>

<P>The member function returns a reference to the stored value <CODE>stored_eng2</CODE>.</P>

<H3><CODE><A NAME="xor_combine::base2_type">xor_combine::base2_type</A></CODE></H3>

<PRE>typedef Engine1 <B>base2_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine2</CODE>.</P>

<H3><CODE><A NAME="xor_combine::max">xor_combine::max</A></CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="xor_combine::min">xor_combine::min</A></CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value in the generated sequence.</P>

<H3><CODE><A NAME="xor_combine::operator()">operator()</A></CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member operator returns <CODE>(stored_eng1() &lt;&lt; shift1) ^ (stored_eng2() &lt;&lt; shift2)</CODE>.</P>

<H3><CODE><A NAME="xor_combine::result_type">xor_combine::result_type</A></CODE></H3>

<PRE>typedef T1 <B>result_type</B>;</PRE>

<P>The type is a synonym for the unnamed type <CODE>T1</CODE>,
which is either <CODE>Engine1::result_type</CODE>
or <CODE>Engine2::result_type</CODE>, whichever has the larger range of
values.</P>

<H3><CODE><A NAME="xor_combine::seed">xor_combine::seed</A></CODE></H3>

<PRE>void <B>seed</B>();
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed function">seed function</A>
calls <CODE>stored_eng1.seed()</CODE> and then calls
<CODE>stored_eng2.seed()</CODE>. The second seed function calls
<CODE>stored_eng1.seed(gen)</CODE> and then calls
<CODE>stored_eng2.seed(gen)</CODE>.</P>

<H3><CODE><A NAME="xor_combine::shift1">xor_combine::shift1</A></CODE></H3>

<PRE>static constexpr int <B>shift1</B> = S1;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S1</CODE>.</P>

<H3><CODE><A NAME="xor_combine::shift2">xor_combine::shift2</A></CODE></H3>

<PRE>static constexpr int <B>shift2</B> = S2;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S2</CODE>.</P>

<H3><CODE><A NAME="xor_combine::xor_combine">xor_combine::xor_combine</A></CODE></H3>

<PRE><B>xor_combine</B>();
<B>xor_combine</B>(result_type x0);
<B>xor_combine</B>(const base1_type&amp; eng1, const base2_type&amp; eng2);
template&lt;class Gen&gt;
    <B>xor_combine</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object with stored values <CODE>stored_eng1</CODE>
and <CODE>stored_eng2</CODE> constructed with their respective default constructors.
The second constructor constructs an object with stored values <CODE>stored_eng1</CODE>
and <CODE>stored_eng2</CODE> constructed with <CODE>x0</CODE> and <CODE>x0 + 1</CODE>,
respectively.
The third constructor constructs an object whose stored value <CODE>stored_eng1</CODE>
holds a copy of <CODE>eng1</CODE> and whose stored value <CODE>stored_eng2</CODE>
holds a copy of <CODE>eng2</CODE>.
The fourth constructor constructs an object and calls <CODE>seed(gen)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by Dinkumware, Ltd. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
