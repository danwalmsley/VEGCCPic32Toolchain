<HTML><HEAD><TITLE>&lt;tuple&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;tuple&gt;"><CODE>&lt;tuple&gt;</CODE></A></H1>

<P>[added with
<A HREF="index.html#TR1">TR1</A>]</P><HR>

<P><B><CODE><A HREF="#begin">begin</A>
&#183; <A HREF="#end">end</A>
&#183; <A HREF="#get">get</A>
&#183; <A HREF="#ignore">ignore</A>
&#183; <A HREF="#make_tuple">make_tuple</A>
&#183; <A HREF="#swap">swap</A>
&#183; <A HREF="#tie">tie</A>
&#183; <A HREF="#tuple">tuple</A>
&#183; <A HREF="#tuple_cat">tuple_cat</A>
&#183; <A HREF="#tuple_element">tuple_element</A>
&#183; <A HREF="#tuple_size">tuple_size</A>
</CODE></B></P>

<P><B><CODE><A HREF="#operator==">operator==</A>
&#183; <A HREF="#operator!=">operator!=</A>
&#183; <A HREF="#operator&lt;">operator&lt;</A>
&#183; <A HREF="#operator&lt;=">operator&lt=</A>
&#183; <A HREF="#operator&gt;">operator&gt;</A>
&#183; <A HREF="#operator&gt;=">operator&gt;=</A>
</CODE></B></P>

<HR>

<P>Include the <A HREF="index.html#TR1">TR1</A>
header <B><CODE>&lt;tuple&gt;</CODE></B> to define a template
<CODE>tuple</CODE> whose instances hold objects of varying types.</P>

<P>Note: Beginning with <B>C++0X</B>,
this header makes extensive use of
<A HREF="lib_cpp.html#variadic templates">variadic templates</A>,
indicated by various uses of ellipsis (<CODE>...</CODE>).
The descriptions below use variadic notation, but still apply to
older compilers, provided the number of parameters in a varying-length
list does not exceed ten.</P>

<PRE>namespace std {
    namespace tr1 {
    // TEMPLATE CLASSES
template&lt;class... Types&gt;
    class <B><A HREF="#tuple">tuple</A></B>;

template&lt;size_t Idx, class Ty&gt;
    class <B><A HREF="#tuple_element">tuple_element</A></B>; // not defined
template&lt;size_t Idx, class... Types&gt;
    class <B><A HREF="#tuple_element">tuple_element</A></B>&lt;Idx, tuple&lt;Types...&gt; &gt;;

template&lt;class Ty&gt;
    class <B><A HREF="#tuple_size">tuple_size</A></B>; // not defined
template&lt;class... Types&gt;
    class <B><A HREF="#tuple_size">tuple_size</A></B>&lt;tuple&lt;Types...&gt; &gt;;

    // TEMPLATE FUNCTIONS
template&lt;size_t Idx, class... Types&gt;
    typename tuple_element&lt;Idx, tuple&lt;Types...&gt; &gt;::type&amp;
        <B><A HREF="#get">get</A></B>(tuple&lt;Types...&amp;&gt; tpl);
template&lt;size_t Idx, class... Types&gt;
    typename tuple_element&lt;Idx, tuple&lt;Types...&gt; &gt;::type&amp;
        <B><A HREF="#get">get</A></B>(const tuple&lt;Types...&amp;&gt; tpl);

template&lt;class... Types&gt;
    tuple&lt;Types2...&gt;
        <B><A HREF="#make_tuple">make_tuple</A></B>(Types...);
template&lt;class... Types&gt;
    tuple&lt;Types&amp;...&gt;
        <B><A HREF="#tie">tie</A></B>(Types&amp;...);
template&lt;class... Types1, class... Types2&gt;
    tuple&lt;Types1..., Types2...&gt;
        <B><A HREF="#tuple_cat">tuple_cat</A></B>(tuple&lt;Types1...&gt;&amp;&amp; t1,
            tuple&lt;Types2...&gt;&amp;&amp; t2); <B>[added with C++0X]</B>
template&lt;class... Types&gt;
    void <B><A HREF="#swap">swap</A></B>(tuple&lt;Types...&amp;&gt; left,
        tuple&lt;Types...&amp;&gt; right);

template&lt;class InIt&gt;
    InIt <B><A HREF="#begin">begin</A></B>(const tuple&lt;InIt, InIt&gt;&amp; pr); <B>[added with C++0X]</B>
template&lt;class InIt&gt;
    InIt <B><A HREF="#end">end</A></B>(const tuple&lt;InIt, InIt&gt;&amp; pr); <B>[added with C++0X]</B>

    // TEMPLATE COMPARISON OPERATORS
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);
template&lt;class... Types1, class... Types2&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);

    // CONST OBJECTS
const T1 <B><A HREF="#ignore">ignore</A></B>;

    }  // namespace tr1
using tr1::get; using tr1::ignore; <B>[added with C++0X]</B>
using tr1::make_tuple; using tr1::ref;
using tr1::tie; using tr1::tuple;
using tr1::tuple_cat; using tr1::tuple_element;
using tr1::tuple_size;
}  // namespace std</PRE>

<H2><CODE><A NAME="begin">begin</A></CODE></H2>

<PRE>template&lt;class InIt&gt;
    InIt <B>begin</B>(const tuple&lt;InIt, InIt&gt;&amp; pr); <B>[added with C++0X]</B></PRE>

<P>The function returns
<CODE><A HREF="#get">get</A>&lt;0&gt;(pr)</CODE>.</P>

<H2><CODE><A NAME="end">end</A></CODE></H2>

<PRE>template&lt;class InIt&gt;
    InIt <B>end</B>(const tuple&lt;InIt, InIt&gt;&amp; pr); <B>[added with C++0X]</B></PRE>

<P>The function returns
<CODE><A HREF="#get">get</A>&lt;1&gt;(pr)</CODE>.</P>

<H2><CODE><A NAME="get">get</A></CODE></H2>

<PRE>template&lt;size_t Idx, class... Types&gt;
    typename tuple_element&lt;Idx, tuple&lt;Types...&gt; &gt;::type&amp;
        <B>get</B>(tuple&lt;Types...&amp;&gt; tpl);
template&lt;size_t Idx, class... Types&gt;
    typename tuple_element&lt;Idx, tuple&lt;Types...&gt; &gt;::type&amp;
        <B>get</B>(const tuple&lt;Types...&amp;&gt; tpl);</PRE>

<P>The template functions return a reference to the value at
<A HREF="#tuple index">index</A> <CODE>Idx</CODE> in the <CODE>tuple</CODE>
object <CODE>tpl</CODE>. If the corresponding type <CODE>Ti</CODE>
in <CODE>Types</CODE> is a reference type,
both functions return <CODE>Ti</CODE>; otherwise the first
function returns <CODE>Ti&amp;</CODE> and the second function returns
<CODE>const Ti&amp;</CODE>.</P>

<H2><CODE><A NAME="ignore">ignore</A></CODE></H2>

<PRE>const T1 <B>ignore</B>;</PRE>

<P>The object has unspecified type <CODE>T1</CODE> and can be assigned
anything with no effect. Note that <CODE>ignore&amp;</CODE> can make a
useful placeholder in a <CODE>tuple</CODE> object.</P>

<H2><CODE><A NAME="make_tuple">make_tuple</A></CODE></H2>

<PRE>template&lt;class... Types&gt;
    tuple&lt;Types2...&gt;
        <B>make_tuple</B>(Types...);</PRE>

<P>The template function returns a <CODE>tuple</CODE> object
constructed from the argument list, where each element type <CODE>T2i</CODE>
in <CODE>Types2</CODE> is determined from the corresponding
<CODE>Ti</CODE> in <CODE>Types</CODE> as follows:</P>

<UL>
<LI>If <CODE>Ti</CODE> is any const/volatile qualified
<CODE><A HREF="functio2.html#reference_wrapper">reference_wrapper</A>&lt;X&gt;</CODE>,
<CODE>T2i</CODE> is <CODE>X&amp;</CODE>.</LI>

<LI>Otherwise, beginning with <B>C++0X</B>, <CODE>T2i</CODE> is
<CODE><A HREF="typetrait.html#decay">decay</A>&lt;Ti&gt;::type</CODE>.</LI>

<LI>Otherwise, <CODE>T2i</CODE> is <CODE>Ti</CODE>.</LI>
</UL>

<H2><CODE><A NAME="operator==">operator==</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator==</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns true only when both tuples are empty, or when
<CODE>get&lt;0&gt;(tpl1) == get&lt;0&gt;(tpl2) &amp;&amp;
...</CODE> for all corresponding elements.</P>

<H2><CODE><A NAME="operator!=">operator!=</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator!=</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns <CODE>!(tpl1 == tpl2)</CODE>.</P>

<H2><CODE><A NAME="operator&lt;">operator&lt;</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator&lt;</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns true only when both tuples are not empty and
<CODE>get&lt;0&gt;(tpl1) &lt; get&lt;0&gt;(tpl2) ||
!(get&lt;0&gt;(tpl2) &lt; get&lt;0&gt;(tpl1)) &amp;&amp;
...</CODE> for all corresponding elements.</P>

<H2><CODE><A NAME="operator&lt;=">operator&lt;=</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator&lt;=</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns <CODE>!(tpl2 &lt; tpl1)</CODE>.</P>

<H2><CODE><A NAME="operator&gt;">operator&gt;</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator&gt;</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns <CODE>tpl2 &lt; tpl1</CODE>.</P>

<H2><CODE><A NAME="operator&gt;=">operator&gt;=</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    bool <B>operator&gt;=</B>(const tuple&lt;Types1...&gt;&amp; tpl1,
        const tuple&lt;Types2...&gt;&amp; tpl2);</PRE>

<P>The function returns <CODE>!(tpl1 &lt; tpl2)</CODE>.</P>


<H2><CODE><A NAME="swap">swap</A></CODE></H2>

<PRE>template&lt;class... Types&gt;
    void <B>swap</B>(tuple&lt;Types...&amp;&gt; left,
        tuple&lt;Types...&amp;&gt; right);</PRE>

<P>The function executes <CODE>left.swap(right)</CODE>.</P>

<H2><CODE><A NAME="tie">tie</A></CODE></H2>

<PRE>template&lt;class... Types&gt;
    tuple&lt;Types&amp;...&gt;
        <B>tie</B>(Types&amp;...);</PRE>

<P>The template function returns a <CODE>tuple</CODE> object
constructed from the argument list, where each element is a reference.
Note that a reference to
<CODE><A HREF="#ignore">ignore</A></CODE> can be assigned anything
and will do nothing.</P>

<H2><CODE><A NAME="tuple">tuple</A></CODE></H2>

<PRE>template&lt;class... Types&gt;
class <B>tuple</B> {
public:
    <B><A HREF="#tuple::tuple">tuple</A></B>();
    explicit <B><A HREF="#tuple::tuple">tuple</A></B>(const Types&amp;...);
    <B><A HREF="#tuple::tuple">tuple</A></B>(const tuple&amp; right);
    template &lt;class... Types2&gt;
        <B><A HREF="#tuple::tuple">tuple</A></B>(const tuple&lt;Types2...&gt;&amp; right);
    template &lt;class U1, class U2&gt;
        <B><A HREF="#tuple::tuple">tuple</A></B>(const pair&lt;U1, U2&gt;&amp; right);

    template &lt;class... Types2&gt;
        explicit <B><A HREF="#tuple::tuple">tuple</A></B>(Types2...&gt;&amp;&amp; args); <B>[added with C++0X]</B>

    <B><A HREF="#tuple::tuple">tuple</A></B>(tuple&amp;&amp; right); <B>[added with C++0X]</B>
    template &lt;class... Types2&gt;
        <B><A HREF="#tuple::tuple">tuple</A></B>(tuple&lt;Types2...&gt;&amp;&amp; right); <B>[added with C++0X]</B>
    template &lt;class U1, class U2&gt;
        <B><A HREF="#tuple::tuple">tuple</A></B>(pair&lt;U1, U2&gt;&amp;&amp; right); <B>[added with C++0X]</B>

    void <B><A HREF="#tuple::swap">swap</A></B>(tuple&amp; right); <B>[added with C++0X]</B>

    tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(const tuple&amp; right);
    template &lt;class... Types2&gt;
        tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(const tuple&lt;Types2...&gt;&amp; right);
    template &lt;class U1, class U2&gt;
        tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(const pair&lt;U1, U2&gt;&amp; right);

    tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(tuple&amp;&amp; right); <B>[added with C++0X]</B>
    template &lt;class... Types2&gt;
        tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(tuple&lt;Types2...&gt;&amp;&amp; right); <B>[added with C++0X]</B>
    template &lt;class U1, class U2&gt;
        tuple&amp; <B><A HREF="#tuple::operator=">operator=</A></B>(pair&lt;U1, U2&gt;&amp;&amp; right); <B>[added with C++0X]</B>
    };</PRE>

<P>The template class describes an object that stores zero or more
objects of types specified by <CODE>Types</CODE>. The
<B><A NAME="tuple extent">extent</A></B> of a tuple instance
is the number <CODE>N</CODE> of its template arguments.
The <B><A NAME="tuple index">index</A></B> of the template
argument <CODE>Ti</CODE> (counting from zero)
and of the corresponding stored value of that type is <CODE>i</CODE>.</P>

<H3><CODE><A NAME="tuple::operator=">tuple::operator=</A></CODE></H3>

<PRE>tuple&amp; <B>operator=</B>(const tuple&amp; right);
template &lt;class... Types2&gt;
    tuple&amp; <B>operator=</B>(const tuple&lt;Types2...&gt;&amp; right);
template &lt;class U1, class U2&gt;
    tuple&amp; <B>operator=</B>(const pair&lt;U1, U2&gt;&amp; right);

tuple&amp; <B>operator=</B>(tuple&amp;&amp; right); <B>[added with C++0X]</B>
template &lt;class... Types2&gt;
    tuple&amp; <B>operator=</B>(tuple&lt;Types2...&gt;&amp;&amp; right); <B>[added with C++0X]</B>
template &lt;class U1, class U2&gt;
    tuple&amp; <B>operator=</B>(pair&lt;U1, U2&gt;&amp;&amp; right); <B>[added with C++0X]</B></PRE>

<P>The first two member operators assign the elements of <CODE>right</CODE> to
the corresponding elements of <CODE>*this</CODE>. The third member operator
assigns <CODE>right.first</CODE> to the element at
<A HREF="#tuple index">index</A> 0
of <CODE>*this</CODE> and <CODE>right.second</CODE> to the element at
index 1. All three member operators return <CODE>*this</CODE>.</P>

<P>The remaining member operators are analogs to earlier ones, but with
<A HREF="lib_cpp.html#rvalue references">rvalue references</A>.</P>

<H3><CODE><A NAME="tuple::swap">tuple::swap</A></CODE></H3>

<PRE>void <B>swap</B>(tuple&amp; right); <B>[added with C++0X]</B></PRE>

<P>The member function calls <CODE>swap</CODE> for each element of <CODE>right</CODE>
and the corresponding element of <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="tuple::tuple">tuple::tuple</A></CODE></H3>

<PRE><B>tuple</B>();
explicit <B>tuple</B>(const Types&amp;...);
<B>tuple</B>(const tuple&amp; right);
template &lt;class... Types2&gt;
    <B>tuple</B>(const tuple&lt;Types2...&gt;&amp; right);
template &lt;class U1, class U2&gt;
    <B>tuple</B>(const pair&lt;U1, U2&gt;&amp; right);

template &lt;class... Types2&gt;
    explicit <B>tuple</B>(Types2...&gt;&amp;&amp; args); <B>[added with C++0X]</B>

<B>tuple</B>(tuple&amp;&amp; right); <B>[added with C++0X]</B>
template &lt;class... Types2&gt;
    <B>tuple</B>(tuple&lt;Types2...&gt;&amp;&amp; right); <B>[added with C++0X]</B>
template &lt;class U1, class U2&gt;
    <B>tuple</B>(pair&lt;U1, U2&gt;&amp;&amp; right); <B>[added with C++0X]</B></PRE>

<P>The first constructor constructs an object whose elements are default
constructed. The second constructor constructs an object whose elements are
copy constructed from the argument list.</P>

<P>The third and fourth constructors
construct an object whose elements are copy constructed from the corresponding
element of <CODE>right</CODE>. The fifth constructor constructs an object whose
element at index 0 is copy constructed from <CODE>right.first</CODE> and whose
element at index 1 is copy constructed from <CODE>right.second</CODE>.</P>

<P>The sixth constructor constructs each of the elements by moving
the corresponding argument.
The remaining constructors are analogs to earlier ones, but with
<A HREF="lib_cpp.html#rvalue references">rvalue references</A>.</P>

<H2><CODE><A NAME="tuple_cat">tuple_cat</A></CODE></H2>

<PRE>template&lt;class... Types1, class... Types2&gt;
    tuple&lt;Types1..., Types2...&gt;
        <B>tuple_cat</B>(tuple&lt;Types1...&gt;&amp;&amp; t1,
            tuple&lt;Types2...&gt;&amp;&amp; t2); <B>[added with C++0X]</B></PRE>

<P>The template function returns an object of type
<CODE>tuple&lt;Types1..., Types2...&gt;</CODE> whose first
<CODE>Types1...</CODE> elements are initialized from <CODE>t1</CODE>
and whose remaining <CODE>Types2...</CODE> elements are initialized
from <CODE>t2</CODE>.</P>

<H2><CODE><A NAME="tuple_element">tuple_element</A></CODE></H2>

<PRE>template&lt;size_t Idx, class Ty&gt;
    class <B>tuple_element</B>; // not defined
template&lt;size_t Idx, class... Types&gt;
    class <B>tuple_element</B>&lt;Idx, tuple&lt;Types...&gt; &gt;;</PRE>

<P>The template class has a member type <CODE>type</CODE> that is a synonym
for the type at <A HREF="#tuple index">index</A> <CODE>Idx</CODE>
of the type <CODE>tuple&lt;Types...&gt;</CODE>.</P>

<H2><CODE><A NAME="tuple_size">tuple_size</A></CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>tuple_size</B>; // not defined
template&lt;class... Types&gt;
    class <B>tuple_size</B>&lt;tuple&lt;Types...&gt; &gt;;</PRE>

<P>The template class has a member <CODE>const size_t value</CODE>
whose value is the <A HREF="#tuple extent">extent</A> of the
type <CODE>tuple&lt;Types...&gt;</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by Dinkumware, Ltd. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
