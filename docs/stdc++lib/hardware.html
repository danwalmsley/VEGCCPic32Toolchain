<HTML><HEAD><TITLE>&lt;hardware&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;hardware&gt;"><CODE>&lt;hardware&gt;</CODE></A></H1>

<P>[added with
<A NAME="TR18015">TR18015</A>]</P><HR>

<P><B><CODE><A HREF="#dynamic_address">dynamic_address</A>
&#183; <A HREF="#hw_base">hw_base</A>
&#183; <A HREF="#platform_traits">platform_traits</A>
&#183; <A HREF="#register_access">register_access</A>
&#183; <A HREF="#register_buffer">register_buffer</A>
&#183; <A HREF="#register_traits">register_traits</A>
&#183; <A HREF="#static_address">static_address</A>
</CODE></B></P>
<HR>

<P>Include the added header <B><CODE>&lt;hardware&gt;</CODE></B>
so that you can write low-level I/O hardware drivers in C++ that
are easier to port to different architectures.</P>

<P>Note that the use of this header does <B>not</B> require
any additions to the C++ language, as none are mandated by TR18015.</P>

<PRE>#include &lt;iohw.h&gt;

namespace std {
    namespace hardware {
class <B><A NAME="hw_base">hw_base</A></B>
    {   // define hardware address type
public:
    enum <B><A NAME="hw_base::access_mode">access_mode</A></B>
        {   // access modes
        <B><A NAME="hw_base::random">random</A></B>,
        <B><A NAME="hw_base::read">read</A></B>,
        <B><A NAME="hw_base::read_write">read_write</A></B>,
        <B><A NAME="hw_base::write">write</A></B>
        };
    enum <B><A NAME="hw_base::device_bus">device_bus</A></B>
        {   // device register widths
        <B><A NAME="hw_base::device8">device8</A></B>,
        <B><A NAME="hw_base::device16">device16</A></B>,
        <B><A NAME="hw_base::device32">device32</A></B>,
        <B><A NAME="hw_base::device64">device64</A></B>
        };
    enum <B><A NAME="hw_base::byte_order">byte_order</A></B>
        {   // endianness
        <B><A NAME="hw_base::msb_low">msb_low</A></B>,
        <B><A NAME="hw_base::msb_high">msb_high</A></B>
        };
    enum <B><A NAME="hw_base::processor_bus">processor_bus</A></B>
        {   // processor bus widths
        <B><A NAME="hw_base::bus8">bus8</A></B>,
        <B><A NAME="hw_base::bus16">bus16</A></B>,
        <B><A NAME="hw_base::bus32">bus32</A></B>,
        <B><A NAME="hw_base::bus64">bus64</A></B>
        };
    enum <B><A NAME="hw_base::data_bus">data_bus</A></B>
        {   // type name for data bus
        };
    enum <B><A NAME="hw_base::io_bus">io_bus</A></B>
        {   // type name for I/O bus
        };
    enum <B><A NAME="hw_base::address_kind">address_kind</A></B>
        {   // addressing model
        <B><A NAME="hw_base::is_static">is_static</A></B>,
        <B><A NAME="hw_base::is_dynamic">is_dynamic</A></B>
        };
    typedef ::ioreg <B><A NAME="hw_base::address_type">address_type</A></B>;  // HARDWARE DEPENDENT
    };

        // TEMPLATE CLASS static_address
template&lt;hw_base::address_type Val&gt;
    class <B><A NAME="static_address">static_address</A></B>
    {   // specialization for value of type hw_base::address_type
public:
    enum
        {   // define value from template parameter
        <B><A NAME="static_address::value_">value_</A></B> = Val
        };
    hw_base::address_type <B><A NAME="static_address::value">value</A></B>() const
        {   // get value of this static address
        return (Val);
        }
    };

        // CLASS dynamic_address
class <B><A NAME="dynamic_address">dynamic_address</A></B>
    {   // store dynamic address
public:
    <B><A NAME="dynamic_address::dynamic_address">dynamic_address</A></B>(hw_base::address_type address);
        :    value_(address)
        {   // construct from address
        }

    hw_base::address_type <B><A NAME="dynamic_address::value">value</A></B>() const
        {   // get value of stored address
        return (value_);
        }

    hw_base::address_type <B><A NAME="dynamic_address::value_">value_</A></B>;
    };

        // CLASS platform_traits
class <B><A NAME="platform_traits">platform_traits</A></B>
    {   // default platform traits (ALL CONTENTS OPTIONAL)
public:
    typedef hw_base::address_type <B><A NAME="platform_traits::address_holder">address_holder</A></B>;
    typedef hw_base::address_type <B><A NAME="platform_traits::processor_bus">processor_bus</A></B>;
    enum
        {   // platform traits
        <B><A NAME="platform_traits::address_mode">address_mode</A></B>,
        <B><A NAME="platform_traits::processor_endianness">processor_endianness</A></B>,
        <B><A NAME="platform_traits::processor_bus_width">processor_bus_width</A></B>
        };
    };

        // CLASS register_traits
class <B><A NAME="register_traits">register_traits</A></B>
    {   // default register traits (ALL CONTENTS OPTIONAL)
public:
    typedef unsigned int <B><A NAME="register_traits::value_type">value_type</A></B>;
    typedef hw_base::address_type <B><A NAME="register_traits::address_holder">address_holder</A></B>;
    enum
        {   // platform traits
        <B><A NAME="register_traits::address_mode">address_mode</A></B>,
        <B><A NAME="register_traits::access_mode">access_mode</A></B>,
        <B><A NAME="register_traits::endianness">endianness</A></B>,
        <B><A NAME="register_traits::device_bus_width">device_bus_width</A></B>
        };
    };

        // TEMPLATE CLASS register_access
template&lt;class Reg_traits = register_traits,
    class Platform_traits = platform_traits&gt;
    class <B><A NAME="register_access">register_access</A></B>
    {   // access wrapper for a hardware I/O register
    typedef typename Platform_traits::address_holder Plat_t;
    typedef typename Reg_traits::address_holder Reg_t;

public:
    typedef typename Reg_traits::value_type <B><A NAME="register_access::value_type">value_type</A></B>;

    <B><A NAME="register_access::register_access">register_access</A></B>();
    <B>register_access</B>(const Plat_t&amp; plat_addr);
    <B>register_access</B>(const Reg_t&amp; reg_addr,
        const Plat_t&amp; plat_addr);

    // access operators
    operator <B><A NAME="register_access::value_type">value_type</A></B>() const;
    void <B><A NAME="register_access::operator=">operator=</A></B>(value_type val);
    void <B><A NAME="register_access::operator!=">operator|=</A></B>(value_type val);
    void <B><A NAME="register_access::operator&amp;=">operator&amp;=</A></B>(value_type val);
    void <B><A NAME="register_access::operator^=">operator^=</A></B>(value_type val);

    // access functions
    value_type <B><A NAME="register_access::read">read</A></B>() const;
    void <B><A NAME="register_access::write">write</A></B>(value_type val);
    void <B><A NAME="register_access::or_with">or_with</A></B>(value_type val);
    void <B><A NAME="register_access::and_with">and_with</A></B>(value_type val);
    void <B><A NAME="register_access::xor_with">xor_with</A></B>(value_type val);
    };

        // TEMPLATE CLASS register_buffer
template&lt;class Reg_traits = register_traits,
    class Platform_traits = platform_traits&gt;
    class <B><A NAME="register_buffer">register_buffer</A></B>
    {   // access wrapper for a hardware I/O register
    typedef typename Platform_traits::address_holder Plat_t;
    typedef typename Reg_traits::address_holder Reg_t;

public:
    typedef register_access&lt;Reg_traits, Platform_traits&gt; <B><A NAME="register_buffer::ref_type">ref_type</A></B>;
    typedef typename Reg_traits::value_type <B><A NAME="register_buffer::value_type">value_type</A></B>;

    <B><A NAME="register_buffer::register_buffer">register_buffer</A></B>();
    <B>register_buffer</B>(const Plat_t&amp; plat_addr);
    <B>register_buffer</B>(const Reg_t&amp; reg_addr,
        const Plat_t&amp; plat_addr);

    // access operators
    ref_type <B><A NAME="register_buffer::operator[]">operator[]</A></B>(ioindex_t idx) const;

    // access functions
    ref_type <B><A NAME="register_buffer::get_buffer_element">get_buffer_element</A></B>(ioindex_t idx) const;
    };
    }    // namespace hardware
}    // namespace std</PRE>

<P>The header <CODE>&lt;hardware&gt;</CODE> defines a number of classes
and templates. You should view
this header as a prototype for defining the C++ interface
to the atomic operations needed to
express a low-level I/O hardware driver.
It supplements the C header <CODE><A HREF="iohw.html">&lt;iohw.h&gt;</A></CODE>.
The facilities in this header are structured around a few basic concepts:</P>

<UL>
<LI>Class <B><CODE>access_mode</CODE></B> supplies the enumeration
constants needed to describes the properties of I/O addresses.
The member type <CODE>address_type</CODE> is used in other classes as the type
of I/O addresses.</LI>

<LI>Class <B><CODE>platform_traits</CODE></B> supplies the enumeration
constants needed to describes the properties of an I/O bus in general.
The member type <CODE>address_holder</CODE> is used in other classes as the type
of I/O addresses. Class <B><CODE>register_traits</CODE></B> performs
a similar role for specific ports on an I/O bus.</LI>

<LI>Template class <B><CODE>static_address</CODE></B> wraps an I/O
address whose value is known at translation time,
while class <B><CODE>dynamic_address</CODE></B>
waps one that might nit be known until program execution.</LI>

<LI>Class <B><CODE>register_access</CODE></B> supplies the member
functions that call actual drivers to perform I/O operations. Similarly,
class <B><CODE>register_buffer</CODE></B> supplies <CODE>register_access</CODE>
objects for different elements of a hardware buffer.</LI>
</UL>

<P>In this 
<A HREF="index.html#implementation">implementation</A>, all operations
are performed by calling one of the five low-level functions
(defined in <CODE>&lt;iohw.h&gt;</CODE>):</P>

<PRE>    iordbuf(_IOHW_NAME, idx)
    iowrbuf(_IOHW_NAME, idx, val)
    ioorbuf(_IOHW_NAME, idx, val)
    ioandbuf(_IOHW_NAME, idx, val)
    ioxorbuf(_IOHW_NAME, idx, val)</PRE>

<P>If the macro <CODE>_IOHW_NAME</CODE> is not defined when the header
<CODE>&lt;hardware&gt;</CODE> is first included, the macro is defined
as <CODE>hardware</CODE>. Further, the code assumes that all I/O
occurs within a flat address space, where the effective port address
is simply the sum of the platform address, the register address, and
the index into a specific buffer.
So you can write code such as:</P>

<PRE>#define KBD         0xffe0  // base address of keyboard ports
#define KBD_STATUS  0       // first of two adjacent ports
#define KBD_DATA    1       // second of two adjacent ports
#define KBD_DONE    0x80    // DONE status bit

extern unsigned int hardware_brd(ioindex_t idx);  // actual driver

typedef std::hardware::register_buffer&lt;&gt; buffer_t;

buffer_t::value_type getkbd()
    {   // read keyboard when ready
    buffer_t status(KBD, KBD_STATUS);
    buffer_t data(KBD, KBD_DATA);

    while ((status.read() & KBD_DONE) == 0)
        ;   // wait until character is present
    return (data);  // read character and clear DONE
    }</PRE>

<P>All actual driver calls will be to the function
(or macro) <CODE>hardware_brd</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by P.J. Plauger. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
