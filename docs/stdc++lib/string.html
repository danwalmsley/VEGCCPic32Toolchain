<HTML><HEAD><TITLE>&lt;string.h&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;string.h&gt;"><CODE>&lt;string.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#memchr">memchr</A>
&#183; <A HREF="#memcmp">memcmp</A>
&#183; <A HREF="#memcpy">memcpy</A>
&#183; <A HREF="#memmove">memmove</A>
&#183; <A HREF="#memset">memset</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#strcat">strcat</A>
&#183; <A HREF="#strchr">strchr</A>
&#183; <A HREF="#strcmp">strcmp</A>
&#183; <A HREF="#strcoll">strcoll</A>
&#183; <A HREF="#strcpy">strcpy</A>
&#183; <A HREF="#strcspn">strcspn</A>
&#183; <A HREF="#strerror">strerror</A>
&#183; <A HREF="#strlen">strlen</A>
&#183; <A HREF="#strncat">strncat</A>
&#183; <A HREF="#strncmp">strncmp</A>
&#183; <A HREF="#strncpy">strncpy</A>
&#183; <A HREF="#strpbrk">strpbrk</A>
&#183; <A HREF="#strrchr">strrchr</A>
&#183; <A HREF="#strspn">strspn</A>
&#183; <A HREF="#strstr">strstr</A>
&#183; <A HREF="#strtok">strtok</A>
&#183; <A HREF="#strxfrm">strxfrm</A>
</CODE></B></P>

<P><B><CODE><A HREF="#errno_t">errno_t</A>
&#183; <A HREF="#memcpy_s">memcpy_s</A>
&#183; <A HREF="#memmove_s">memmove_s</A>
&#183; <A HREF="#rsize_t">rsize_t</A>
&#183; <A HREF="#strcat_s">strcat_s</A>
&#183; <A HREF="#strcpy_s">strcpy_s</A>
&#183; <A HREF="#strerror_s">strerror_s</A>
&#183; <A HREF="#strerrorlen_s">strerrorlen_s</A>
&#183; <A HREF="#strncat_s">strncat_s</A>
&#183; <A HREF="#strncpy_s">strncpy_s</A>
&#183; <A HREF="#strnlen_s">strnlen_s</A>
&#183; <A HREF="#strtok_s">strtok_s</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;string.h&gt;</CODE></B> to declare a
number of functions that help you manipulate
<A HREF="lib_over.html#C string">C strings</A> and other arrays of
characters.</P>

<PRE>    /* MACROS */
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>

    /* TYPES */
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;

    /* FUNCTIONS */
int <A HREF="#memcmp"><B>memcmp</B></A>(const void *s1, const void *s2, size_t n);
void *<A HREF="#memcpy"><B>memcpy</B></A>(void *restrict s1, const void *restrict s2, size_t n);
void *<A HREF="#memmove"><B>memmove</B></A>(void *s1, const void *s2, size_t n);
void *<A HREF="#memset"><B>memset</B></A>(void *s, int c, size_t n);
char *<A HREF="#strcat"><B>strcat</B></A>(char *restrict s1, const char *restrict s2);
int <A HREF="#strcmp"><B>strcmp</B></A>(const char *s1, const char *s2);
int <A HREF="#strcoll"><B>strcoll</B></A>(const char *s1, const char *s2);
char *<A HREF="#strcpy"><B>strcpy</B></A>(char *restrict s1, const char *restrict s2);
size_t <A HREF="#strcspn"><B>strcspn</B></A>(const char *s1, const char *s2);
char *<A HREF="#strerror"><B>strerror</B></A>(int errcode);
size_t <A HREF="#strlen"><B>strlen</B></A>(const char *s);
char *<A HREF="#strncat"><B>strncat</B></A>(char *restrict s1, const char *restrict s2, size_t n);
int <A HREF="#strncmp"><B>strncmp</B></A>(const char *s1, const char *s2, size_t n);
char *<A HREF="#strncpy"><B>strncpy</B></A>(char *restrict s1, const char *restrict s2, size_t n);
size_t <A HREF="#strspn"><B>strspn</B></A>(const char *s1, const char *s2);
char *<A HREF="#strtok"><B>strtok</B></A>(char *restrict s1, const char *restrict s2);
size_t <A HREF="#strxfrm"><B>strxfrm</B></A>(char *restrict s1, const char *restrict s2, size_t n);

void *<A HREF="#memchr"><B>memchr</B></A>(const void *s, int c,
    size_t n); <B>[not in C++]</B>
const void *<A HREF="#memchr"><B>memchr</B></A>(const void *s, int c,
    size_t n); <B>[C++ only]</B>
void *<A HREF="#memchr"><B>memchr</B></A>(void *s, int c, size_t n); <B>[C++ only]</B>

char *<A HREF="#strchr"><B>strchr</B></A>(const char *s, int c); <B>[not in C++]</B>
const char *<A HREF="#strchr"><B>strchr</B></A>(const char *s, int c); <B>[C++ only]</B>
char *<A HREF="#strchr"><B>strchr</B></A>(char *s, int c); <B>[C++ only]</B>

char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<A HREF="#strpbrk"><B>strpbrk</B></A>(char *s1, const char *s2); <B>[C++ only]</B>

char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s, int c); <B>[not in C++]</B>
const char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s, int c); <B>[C++ only]</B>
char *<A HREF="#strrchr"><B>strrchr</B></A>(char *s, int c); <B>[C++ only]</B>

char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<A HREF="#strstr"><B>strstr</B></A>(char *s1, const char *s2); <B>[C++ only]</B>

#if __STDC_WANT_LIB_EXT1__ <B>[added with <A HREF="index_ext1.html#TR24731">TR24731</A>]</B>
typedef int <A HREF="#errno_t"><B>errno_t</B></A>;
typedef size_t <A HREF="#rsize_t"><B>rsize_t</B></A>;

errno_t <A HREF="#memcpy_s"><B>memcpy_s</B></A>(void *restrict s1, rsize_t maxsize,
    const void *restrict s2, rsize_t n);
errno_t <A HREF="#memmove_s"><B>memmove_s</B></A>(void *s1, rsize_t maxsize,
    const void *s2, rsize_t n);

errno_t <A HREF="#strcpy_s"><B>strcpy_s</B></A>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2);
errno_t <A HREF="#strncpy_s"><B>strncpy_s</B></A>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2, rsize_t n);
errno_t <A HREF="#strcat_s"><B>strcat_s</B></A>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2);
errno_t <A HREF="#strncat_s"><B>strncat_s</B></A>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2, rsize_t n);
char *<A HREF="#strtok_s"><B>strtok_s</B></A>(char *restrict s1, rsize_t *restrict psize1,
    const char *restrict s2, char **restrict pbuf1);

errno_t <A HREF="#strerror_s"><B>strerror_s</B></A>(char *s, rsize_t maxsize,
    errno_t errcode);
size_t <A HREF="#strerrorlen_s"><B>strerrorlen_s</B></A>(errno_t errcode);

size_t <A HREF="#strnlen_s"><B>strnlen_s</B></A>(const char *restrict s, size_t maxsize);
#endif /* __STDC_WANT_LIB_EXT1__ */</PRE>

<H2><A NAME="errno_t"><CODE>errno_t</CODE></A></H2>

<PRE>typedef int <B>errno_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <I>int,</I> used to represent
a value that can be stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="memchr"><CODE>memchr</CODE></A></H2>

<PRE>void *<B>memchr</B>(const void *s, int c,
    size_t n); <B>[not in C++]</B>
const void *<B>memchr</B>(const void *s, int c,
    size_t n); <B>[C++ only]</B>
void *<B>memchr</B>(void *s, int c, size_t n); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of an array of <I>unsigned
char,</I> beginning at the address <CODE>s</CODE> with size <CODE>n</CODE>,
that equals <CODE>(unsigned char)c</CODE>. If successful, it returns the
address of the matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="memcmp"><CODE>memcmp</CODE></A></H2>

<PRE>int <B>memcmp</B>(const void *s1, const void *s2, size_t n);</PRE>

<P>The function compares successive elements from two arrays of <I>unsigned
char,</I> beginning at the addresses <CODE>s1</CODE> and <CODE>s2</CODE>
(both of size <CODE>n</CODE>),
until it finds elements that are not equal:</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE>, the function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="memcpy"><CODE>memcpy</CODE></A></H2>

<PRE>void *<B>memcpy</B>(void *restrict s1, const void *restrict s2, size_t n);</PRE>

<P>The function copies the array of <I>char</I> beginning at the address
<CODE>s2</CODE> to the array of <I>char</I> beginning at the address
<CODE>s1</CODE> (both of size <CODE>n</CODE>). It returns
<CODE>s1</CODE>. The elements of the arrays can be accessed and stored in any
order.</P>

<H2><A NAME="memcpy_s"><CODE>memcpy_s</CODE></A></H2>

<PRE>errno_t <B>memcpy_s</B>(void *restrict s1, rsize_t maxsize,
    const void *restrict s2, size_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than <CODE>maxsize</CODE></LI>

<LI>the array of <CODE>n</CODE> <I>char</I> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>n</CODE> <I>char</I> beginning
at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores null characters in the first <CODE>maxsize</CODE>
elements of the array of <I>char</I> beginning at the address <CODE>s1</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the array of <I>char</I>
beginning at the address
<CODE>s2</CODE> to the array of <I>char</I> beginning at the address
<CODE>s1</CODE> (both of size <CODE>n</CODE>). It returns zero.</P>

<H2><A NAME="memmove"><CODE>memmove</CODE></A></H2>

<PRE>void *<B>memmove</B>(void *s1, const void *s2, size_t n);</PRE>

<P>The function copies the array of <I>char</I> beginning at
<CODE>s2</CODE> to the array of <I>char</I> beginning at <CODE>s1</CODE>
(both of size <CODE>n</CODE>). It returns <CODE>s1</CODE>. If the arrays
overlap, the function accesses each of the element values from
<CODE>s2</CODE> before it stores a new value in that element, so the copy is
not corrupted.</P>

<H2><A NAME="memmove_s"><CODE>memmove_s</CODE></A></H2>

<PRE>errno_t <B>memmove_s</B>(void *s1, rsize_t maxsize,
    const void *s2, size_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than <CODE>maxsize</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores null characters in the first <CODE>maxsize</CODE>
elements of the array of <I>char</I> beginning at the address <CODE>s1</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the array of <I>char</I> beginning at
<CODE>s2</CODE> to the array of <I>char</I> beginning at <CODE>s1</CODE>
(both of size <CODE>n</CODE>). It returns zero. If the arrays
overlap, the function accesses each of the element values from
<CODE>s2</CODE> before it stores a new value in that element, so the copy is
not corrupted.</P>

<H2><A NAME="memset"><CODE>memset</CODE></A></H2>

<PRE>void *<B>memset</B>(void *s, int c, size_t n);</PRE>

<P>The function stores <CODE>(unsigned char)c</CODE> in each of the
elements of the array of <I>unsigned char</I> beginning at <CODE>s</CODE>,
with size <CODE>n</CODE>. It returns <CODE>s</CODE>.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="rsize_t"><CODE>rsize_t</CODE></A></H2>

<PRE>typedef size_t <B>rsize_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <CODE>size_t</CODE>,
used to represent a function argument to be checked on entry
to a function. It is a
<A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
for an argument of type <CODE>rsize_t</CODE> to be greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="strcat"><CODE>strcat</CODE></A></H2>

<PRE>char *<B>strcat</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>The function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I> that stores the string <CODE>s1</CODE>,
beginning with the element that stores
the terminating null character of <CODE>s1</CODE>. It returns
<CODE>s1</CODE>.</P>

<H2><A NAME="strcat_s"><CODE>strcat_s</CODE></A></H2>

<PRE>errno_t <B>strcat_s</B>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI>the value <CODE>M</CODE>, given by
<CODE>maxsize - <A HREF="#strnlen_s">strnlen_s</A>(s1, maxsize)</CODE>,
is not greater than <CODE>N</CODE>, given by
<CODE>strnlen_s(s2, M)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <I>char</I> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N + 1</CODE> <I>char</I> beginning
at the address <CODE>s2 + M</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I> that stores the string <CODE>s1</CODE>,
beginning with the element that stores
the terminating null character of <CODE>s1</CODE>.
It returns zero.</P>

<H2><A NAME="strchr"><CODE>strchr</CODE></A></H2>

<PRE>char *<B>strchr</B>(const char *s, int c); <B>[not in C++]</B>
const char *<B>strchr</B>(const char *s, int c); <B>[C++ only]</B>
char *<B>strchr</B>(char *s, int c); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of the string
<CODE>s</CODE> that equals <CODE>(char)c</CODE>. It considers the
terminating null character as part of the string. If successful, the function
returns the address of the matching element; otherwise, it returns a null
pointer.</P>

<H2><A NAME="strcmp"><CODE>strcmp</CODE></A></H2>

<PRE>int <B>strcmp</B>(const char *s1, const char *s2);</PRE>

<P>The function compares successive elements from two strings,
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not
equal.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the
function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="strcoll"><CODE>strcoll</CODE></A></H2>

<PRE>int <B>strcoll</B>(const char *s1, const char *s2);</PRE>

<P>The function compares two strings, <CODE>s1</CODE> and
<CODE>s2</CODE>, using a comparison rule that depends on the current
<A HREF="locale.html#locale">locale</A>. If <CODE>s1</CODE>
compares greater than <CODE>s2</CODE> by this rule, the function returns a
positive number. If the two strings compare equal,
it returns zero. Otherwise, it returns a negative number.</P>

<H2><A NAME="strcpy"><CODE>strcpy</CODE></A></H2>

<PRE>char *<B>strcpy</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>The function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I>
whose first element has the address <CODE>s1</CODE>. It returns
<CODE>s1</CODE>.</P>

<H2><A NAME="strcpy_s"><CODE>strcpy_s</CODE></A></H2>

<PRE>errno_t <B>strcpy_s</B>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is not greater than <CODE>N</CODE>, given by
<CODE><A HREF="#strnlen_s">strnlen_s</A>(s2, maxsize)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <I>char</I> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N + 1</CODE> <I>char</I> beginning
at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I>
whose first element has the address <CODE>s1</CODE>.
It returns zero.</P>

<H2><A NAME="strcspn"><CODE>strcspn</CODE></A></H2>

<PRE>size_t <B>strcspn</B>(const char *s1, const char *s2);</PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>any one</I> of the elements of the string <CODE>s2</CODE> and
returns <CODE>i</CODE>. Each terminating null character
is considered part of its string.</P>

<H2><A NAME="strerror"><CODE>strerror</CODE></A></H2>

<PRE>char *<B>strerror</B>(int errcode);</PRE>

<P>The function returns a pointer to an internal static-duration object
containing the
<A NAME="error message string"><B>error message string</B></A>
corresponding to the error code <CODE>errcode</CODE>.
The program must not alter any of the values stored in
this object. A later call to <CODE>strerror</CODE> can alter the value stored
in this object.</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="strerror_s"><CODE>strerror_s</CODE></A></H2>

<PRE>errno_t <B>strerror_s</B>(char *restrict s, rsize_t maxsize,
    errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>
</UL>

<P>If such a violation occurs, the function returns
the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies into <CODE>s</CODE> at most
<CODE>maxsize - 1</CODE> characters from the
<A HREF="#error message string">error message string</A>
corresponding to the error code <CODE>errcode</CODE>
and appends a null character. If not all of the message string is copied,
and if <CODE>3 &lt; maxsize</CODE>, then the string <CODE>"..."</CODE>
overwrites the last three characters of the copied string.</P>

<P>The function returns zero.</P>

<H2><A NAME="strerrorlen_s"><CODE>strerrorlen_s</CODE></A></H2>

<PRE>size_t <B>strerrorlen_s</B>(errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The function returns the length of the
<A HREF="#error message string">error message string</A>
corresponding to the error code <CODE>errcode</CODE>.</P>

<H2><A NAME="strlen"><CODE>strlen</CODE></A></H2>

<PRE>size_t <B>strlen</B>(const char *s);</PRE>

<P>The function returns the number of characters in the string
<CODE>s</CODE>, <I>not</I> including its terminating null character.</P>

<H2><A NAME="strncat"><CODE>strncat</CODE></A></H2>

<PRE>char *<B>strncat</B>(char *restrict s1, const char *restrict s2, size_t n);</PRE>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including
its terminating null character, to successive elements of the array of
<I>char</I> that stores the string <CODE>s1</CODE>, beginning with the
element that stores the terminating null character of <CODE>s1</CODE>. The
function copies no more than <CODE>n</CODE> characters from
<CODE>s2</CODE>. It then stores a null character, in the next element to be
altered in <CODE>s1</CODE>, and returns <CODE>s1</CODE>.</P>

<H2><A NAME="strncat_s"><CODE>strncat_s</CODE></A></H2>

<PRE>errno_t <B>strncat_s</B>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI>the value <CODE>M</CODE>, given by
<CODE>maxsize - <A HREF="#strnlen_s">strnlen_s</A>(s1, maxsize)</CODE>,
is not greater than <CODE>N</CODE>, given by
<CODE>strnlen_s(s2, n)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <I>char</I> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N + 1</CODE> <I>char</I> beginning
at the address <CODE>s2 + M</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the string <CODE>s2</CODE>,
<I>not</I> including its terminating null character,
to successive elements of the array of
<I>char</I> that stores the string <CODE>s1</CODE>, beginning with the
element that stores the terminating null character of <CODE>s1</CODE>. The
function copies no more than <CODE>n</CODE> characters from
<CODE>s2</CODE>. It then stores a null character, in the next element to be
altered in <CODE>s1</CODE>, and returns zero.</P>

<H2><A NAME="strncmp"><CODE>strncmp</CODE></A></H2>

<PRE>int <B>strncmp</B>(const char *s1, const char *s2, size_t n);</PRE>

<P>The function compares successive elements from two strings,
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not
equal or until it has compared the first <CODE>n</CODE> elements of the two
strings.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the
function returns a positive number.

<LI>Otherwise, it returns a negative number.
</UL>

<H2><A NAME="strncpy"><CODE>strncpy</CODE></A></H2>

<PRE>char *<B>strncpy</B>(char *restrict s1, const char *restrict s2, size_t n);</PRE>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including
its terminating null character, to successive elements of the array of
<I>char</I> whose first element has the address <CODE>s1</CODE>. It copies no
more than <CODE>n</CODE> characters from <CODE>s2</CODE>. The function then
stores zero or more null characters in the next elements to be altered in
<CODE>s1</CODE> until it stores a total of <CODE>n</CODE> characters. It
returns <CODE>s1</CODE>.</P>

<H2><A NAME="strncpy_s"><CODE>strncpy_s</CODE></A></H2>

<PRE>errno_t <B>strncpy_s</B>(char *restrict s1, rsize_t maxsize,
    const char *restrict s2, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is not greater than <CODE>N</CODE>, given by
<CODE><A HREF="#strnlen_s">strnlen_s</A>(s2, n)</CODE></LI>

<LI>the array of <CODE>N</CODE> <I>char</I> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N</CODE> <I>char</I> beginning
at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the string <CODE>s2</CODE>,
<I>not</I> including its terminating null character, to successive
elements of the array of <I>char</I> whose first element has
the address <CODE>s1</CODE>. It copies no
more than <CODE>n</CODE> characters from <CODE>s2</CODE>. The function then
stores a null character in the next elements to be altered in
<CODE>s1</CODE>. It returns zero.</P>

<H2><A NAME="strnlen_s"><CODE>strnlen_s</CODE></A></H2>

<PRE>size_t <B>strnlen_s</B>(const char *s, size_t maxsize); <B>[added with TR24731]</B></PRE>

<P>If <CODE>s</CODE> is a null pointer, the function returns zero.
Otherwise, if a null character occurs in the first <CODE>maxsize</CODE>
elements of the array beginning at <CODE>s</CODE>, the function
returns the number of characters before the first null character.
Otherwise, the function returns <CODE>maxsize</CODE>.</P>

<H2><A NAME="strpbrk"><CODE>strpbrk</CODE></A></H2>

<PRE>char *<B>strpbrk</B>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<B>strpbrk</B>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<B>strpbrk</B>(char *s1,
    const char *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>any one</I> of the elements of the string <CODE>s2</CODE>. It
considers each terminating null character as part of its string. If
<CODE>s1[i]</CODE> is not the terminating null character, the
function returns <CODE>&amp;s1[i]</CODE>; otherwise, it returns a
null pointer.</P>

<H2><A NAME="strrchr"><CODE>strrchr</CODE></A></H2>

<PRE>char *<B>strrchr</B>(const char *s, int c); <B>[not in C++]</B>
const char *<B>strrchr</B>(const char *s, int c); <B>[C++ only]</B>
char *<B>strrchr</B>(char *s, int c); <B>[C++ only]</B></PRE>

<P>The function searches for the last element of the string <CODE>s</CODE>
that equals <CODE>(char)c</CODE>. It considers the terminating null character
as part of the string. If successful, the function returns the address of the
matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="strspn"><CODE>strspn</CODE></A></H2>

<PRE>size_t <B>strspn</B>(const char *s1, const char *s2);</PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>none</I> of the elements of the string <CODE>s2</CODE> and returns
<CODE>i</CODE>. It considers the terminating null character
as part of the string <CODE>s1</CODE> only.</P>

<H2><A NAME="strstr"><CODE>strstr</CODE></A></H2>

<PRE>char *<B>strstr</B>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<B>strstr</B>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<B>strstr</B>(char *s1, const char *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first sequence of elements in the string
<CODE>s1</CODE> that matches the sequence of elements in the string
<CODE>s2</CODE>, <I>not</I> including its terminating null character. If
successful, the function returns the address of the matching first element;
otherwise, it returns a null pointer.</P>

<H2><A NAME="strtok"><CODE>strtok</CODE></A></H2>

<PRE>char *<B>strtok</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>If <CODE>s1</CODE> is not a null pointer,
the function begins a search of the string <CODE>s1</CODE>.
If <CODE>s1</CODE> is a null pointer, it begins a search of the string
whose address was last stored in an internal static-duration object on an
earlier call to the function, as described below. The search proceeds as
follows:</P>

<OL>
<LI>The function searches the string for <CODE>begin</CODE>,
the address of the first element that equals
<I>none</I> of the elements of the string
<CODE>s2</CODE> (a set of token separators). It considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object (so
that a subsequent search beginning with that address will fail) and returns a
null pointer. Otherwise, the function searches from <CODE>begin</CODE> for
<CODE>end</CODE>, the address of the first element
that equals <I>any one</I> of the elements of the string <CODE>s2</CODE>.
It again considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object.
Otherwise, it stores a null character in the element whose address is
<CODE>end</CODE>. Then it stores the address
of the next element after <CODE>end</CODE> in
the internal static-duration object
(so that a subsequent search beginning with
that address will continue with the remaining elements of the string) and
returns <CODE>begin</CODE>.
</OL>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="strtok_s"><CODE>strtok_s</CODE></A></H2>

<PRE>char 8<B>strtok_s</B>(char *restrict s1, rsize_t *restrict psize1,
    const char *restrict s2, char **restrict pbuf1); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime constraint violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>psize1</CODE> is a null pointer</LI>

<LI><CODE>*psize1</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>pbuf1</CODE> is a null pointer</LI>

<LI>the function fails to find the locations <CODE>begin</CODE>
or <CODE>end</CODE>, or a null character,
in the first <CODE>*psize1</CODE> elements of
the array to be searched as described below</LI>
</UL>

<P>If such a violation occurs,
the function stores nothing and returns a null pointer.</P>

<P>Otherwise, if <CODE>s1</CODE> is not a null pointer,
the function begins a search of the string <CODE>s1</CODE>.
If <CODE>s1</CODE> is a null pointer, it begins a search of the string
whose address was last stored in an internal static-duration object on an
earlier call to the function, as described below. The search proceeds as
follows:</P>

<OL>
<LI>The function searches the string for <CODE>begin</CODE>,
the address of the first element that equals
<I>none</I> of the elements of the string
<CODE>s2</CODE> (a set of token separators). It considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object (so
that a subsequent search beginning with that address will fail) and returns a
null pointer. Otherwise, the function searches from <CODE>begin</CODE> for
<CODE>end</CODE>, the address of the first element
that equals <I>any one</I> of the elements of the string <CODE>s2</CODE>.
It again considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object.
Otherwise, it stores a null character in the element whose address is
<CODE>end</CODE>. Then it stores the address
of the next element after <CODE>end</CODE> in
the internal static-duration object
(so that a subsequent search beginning with
that address will continue with the remaining elements of the string) and
returns <CODE>begin</CODE>.
</OL>

<H2><A NAME="strxfrm"><CODE>strxfrm</CODE></A></H2>

<PRE>size_t <B>strxfrm</B>(char *restrict s1, const char *restrict s2, size_t n);</PRE>

<P>The function stores a string in the array of <I>char</I> whose first
element has the address <CODE>s1</CODE>. It stores no more than
<CODE>n</CODE> characters, <I>including</I> the terminating null character,
and returns the number of characters needed to represent the entire string,
<I>not</I> including the terminating null character. If the value returned is
<CODE>n</CODE> or greater, the values stored in the array are indeterminate.
(If <CODE>n</CODE> is zero, <CODE>s1</CODE> can be a null pointer.)</P>

<P><CODE>strxfrm</CODE> generates the string it stores from the string
<CODE>s2</CODE> by using a transformation rule that depends on the current
<A HREF="locale.html#locale">locale</A>.
For example, if <CODE>x</CODE> is a transformation
of <CODE>s1</CODE> and <CODE>y</CODE> is a transformation
of <CODE>s2</CODE>, then
<CODE><A HREF="#strcmp">strcmp</A>(x, y)</CODE>
returns the same value as
<CODE><A HREF="#strcoll">strcoll</A>(s1, s2)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2010
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V5.30:126I--></BODY></HTML>
